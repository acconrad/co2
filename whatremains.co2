;; -*- mode: lisp; -*-
;; What Remains 
;; Copyright (C) 2016 What Remains Entertainment Consortium
;;
;; Licence TBD

(do
 ;; NES header follows

 (asm
  ".byte \"NES\",$1a" ;; "NES" followed by MS-DOS end-of-file
   ".byte $02" ;; number of prg-rom blocks in 16 KB units
   ".byte $03"  ;; number of chr-rom blocks 8 KB units (value 0 means the board uses CHR RAM)   
   ".byte $11" ;; flags 6 (mapper = 1 in high nybble), vertical mirror in lower nybble
   ".byte $00" ;; flags 7 - more rom control bytes
   ".byte $00,$00,$00,$00,$00,$00,$00,$00")
 
    ;; our memory layout
 (defconst sprite-shadow "$200") ;; where the sprite control data is
 (defconst sprite-dma    "#$2") ;; dma address is 100X this = $200
 (defconst display-list  "$300") ;; the display list
 (defconst pad-data      "$400") ;; cache of the current pad state
 (defconst entity-data   "$500") ;; entity state list

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; display commands
 ;; ----------------
 ;; 
 ;; tile-data display primitive: [list of bytes to copy as tile ids]
 (defconst command-tile-data "#$01")
 ;; tile-value display primitive: [length tile-id] 
 ;; for clearing screen etc - 128 long is about max for timing
 (defconst command-tile-value "#$02")
 ;; 2x2 tile quad [tile top left id]
 (defconst command-quad "#$03")
 ;; rom dump [high low length] - 64 maxish
 (defconst command-rom-data "#$04")
 ;; palette change [palette-id]
 (defconst command-palette-change "#$05")

 (defconst screen-blank-delay "#30")
 
 (defconst title-palette-id "#0")
 (defconst eighties-palette-id "#1")
 (defconst future-palette-id "#2")
 (defconst black-palette-id "#3")
 
 ;; famitone stuff
 (asm "FT_BASE_ADR = $0600 ;; page in the RAM used for FT2 variables, should be $xx00
       FT_TEMP = $f9 ;; 3 bytes in zeropage used by the library as a scratchpad
       FT_DPCM_OFF = $c000  
       FT_SFX_STREAMS = 4 ;; number of sound effects played at once, 1..4
       FT_DPCM_ENABLE	;; undefine to exclude all DMC code
       FT_SFX_ENABLE	;; undefine to exclude all sound effects code
       FT_THREAD	;; undefine if you are calling sound effects from the same thread as the sound update call
       FT_PAL_SUPPORT   ;; undefine to exclude PAL support
       FT_NTSC_SUPPORT	;; undefine to exclude NTSC support
  ")

 ;; code start
 (org #x8000)
 
 ;; we love globals 
 (defvar gframe 0) ;; 8bit frame counter
 (defvar ganim-frame 0) ;; global anim frame for sprite animation  
 (defvar ggame-mode 0) ;; stores what section of the game we are in, title/eighties/future
 (defvar gtext-box 0) ;; are we showing a text box?
 ;; draw-phase ramps from 0-255 when game modes are switched, for 
 ;; sequencing initialisation/drawlist updates 
 (defvar gdraw-phase 0)
 
 ;; the current display list index 
 (defvar display-list-index 0)

 (defvar gscroll-x 0)
 (defvar gscroll-y 0)

 ;; random locals for use anywhere
 (defvar n 0)
 (defvar i 0)
 (defvar j 0)
 (defvar k 0)
 (defvar l 0)
 (defvar m 0)
 (defvar o 0)
 (defvar p 0)
 (defvar start 0)
 (defvar end 0)

 ;; text display globals
 (defvar text-pos 0)
 (defvar text-time 0) 
 (defvar text-addr 0)
 (defvar text-addr-h 0)

 (defvar setup-eighties 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; library code follows

 (defun (enable-rendering)
   ;; ;; set basic ppu registers.  load background from $0000,
   ;; ;; sprites from $1000, and the name table from $2000.
   (set! reg-ppu-ctl #b10001000)
   (set! reg-ppu-mask #b00011110))

 (defun (disable-rendering)
   (set! reg-ppu-ctl 0)
   (set! reg-ppu-mask 0)
   (set! reg-ppu-scroll 0)
   (set! reg-ppu-scroll 0))

 ;; mmc1 stuff 
 (defun (mmc1-control a)
   a ;; get argument into register
   ;; rotate into serial output
   (asm "sta $8000")
   (asm "lsr a")
   (asm "sta $8000")
   (asm "lsr a")
   (asm "sta $8000")
   (asm "lsr a")
   (asm "sta $8000")
   (asm "lsr a")
   (asm "sta $8000"))

 (defun (mmc1-chrbank0 a)
   a
   (asm "sta $a000")
   (asm "lsr a")
   (asm "sta $a000")
   (asm "lsr a")
   (asm "sta $a000")
   (asm "lsr a")
   (asm "sta $a000")
   (asm "lsr a")
   (asm "sta $a000"))

 (defun (mmc1-chrbank1 a)
   a
   (asm "sta $c000")
   (asm "lsr a")
   (asm "sta $c000")
   (asm "lsr a")
   (asm "sta $c000")
   (asm "lsr a")
   (asm "sta $c000")
   (asm "lsr a")
   (asm "sta $c000"))

 ;; calls the random number generator
 (defun (rnd) (_rnd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; sound
 (defun (init-sound)
   (asm "ldx #<danger_streets_music_data	;play second song
   	ldy #>danger_streets_music_data
   	lda #80
   	jsr FamiToneInit
   	lda #0
   	jsr FamiToneMusicPlay")

   ;; (asm "ldx #<after_the_rain_music_data	;play second song
   ;; 	ldy #>after_the_rain_music_data
   ;; 	lda #80
   ;; 	jsr FamiToneInit
   ;; 	lda #0
   ;; 	jsr FamiToneMusicPlay")
   
   0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; input stuff

 (defun (read-joypad)
   ;; need to 'strobe' register before reading
   (set! reg-joypad-0 1)
   (set! reg-joypad-0 0)
   (loop n 0 8
         (poke! pad-data n (and (peek reg-joypad-0) #x1))))

 (defun (pressed key)
   (peek pad-data key))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; the display list

 ;; adds a byte to the list
 (defun (display-list-add-byte data)
   (poke! display-list display-list-index data) 
   (inc display-list-index))

 ;; finishes a packet for rendering
 (defun (display-list-end-packet command-id x y nbytes)
   (poke! display-list display-list-index command-id) 
   (inc display-list-index)
   (poke! display-list display-list-index x)
   (inc display-list-index)
   (poke! display-list display-list-index y)
   (inc display-list-index)
   ;; last byte needs to be size for all commands
   (poke! display-list display-list-index nbytes) 
   (inc display-list-index))

 ;; clear pending commands
 (defun (display-list-flush)
   (set! display-list-index 0))

 ;; to be called in vblank, all ppu updates should be in here
 (defun (display-list-execute)
   ;; is there anything in the queue?
   (if (eq? display-list-index 0) 0 ;; early out (avoid long branch)
     (do
      ;; reverse to read info (lifo for ease/speed)
      (set! display-list-index (- display-list-index 4))

      (set! n (peek display-list (+ display-list-index 3))) ;; store nbytes
      (set! start (- display-list-index n))
      (set! end display-list-index)

      ;; update tile data
      (when (eq? (peek display-list display-list-index) command-tile-data) 
	(set! end display-list-index)
	(ppu-memcpy ppu-name-table-0 
		    (peek display-list (+ display-list-index 1)) 
		    (peek display-list (+ display-list-index 2))
		    end ;; w
		    display-list
		    start)) ;; start

      ;; update arbitrary length strips of one value (RLE)
      (when (eq? (peek display-list display-list-index) command-tile-value) ;; tileset
	(ppu-memset ppu-name-table-0 
		    (peek display-list (+ display-list-index 1)) 
		    (peek display-list (+ display-list-index 2))
		    (peek display-list start) ;; length
		    (peek display-list (+ start 1)))) ;; tile id

      ;; 2x2 metatile block
      (when (eq? (peek display-list display-list-index) command-quad) 
	(set! o (peek display-list (+ display-list-index 1)))
	(set! p (peek display-list (+ display-list-index 2)))
	(set! i (peek display-list start))
	;; could be optimised a lot
	(ppu-memset ppu-name-table-0 o p 1 i) 
	(ppu-memset ppu-name-table-0 o (+ p 1) 1 (+ i 1)) 
	(ppu-memset ppu-name-table-0 o (+ p 32) 1 (+ i 16)) 
	(ppu-memset ppu-name-table-0 o (+ p 33) 1 (+ i 17))
	)

      ;; copy from PRG-ROM to tile data
      (when (eq? (peek display-list display-list-index) command-rom-data) 
	(set! o (peek display-list start)) ;; prg high
	(set! p (peek display-list (+ start 1))) ;; prg low
	(set! i (peek display-list (+ start 2))) ;; length
	(ppu-memcpy16 ppu-name-table-0 
		      (peek display-list (+ display-list-index 1)) 
		      (peek display-list (+ display-list-index 2))
		      i o))

      (when (eq? (peek display-list display-list-index) command-palette-change) 
	(set! o (peek display-list start)) ;; palette index
	(cond
	 ((eq? o title-palette-id) (ppu-memcpy ppu-palette 0 0 #x20 title_palette 0))
	 ((eq? o eighties-palette-id) (ppu-memcpy ppu-palette 0 0 #x20 eighties_palette 0))
	 ((eq? o future-palette-id) (ppu-memcpy ppu-palette 0 0 #x20 future_palette 0))
	 (else (ppu-memcpy ppu-palette 0 0 #x20 black_palette 0))))
      
      (set! display-list-index (- display-list-index n)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; utilities that use the display list

 ;; clear screen
 (defun (clear-tiles)
   ;; nametable 1
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 0 0 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 0 128 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 1 0 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 1 128 2)
   ;; nametable 2
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 2 0 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 2 128 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 3 0 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 3 128 2))

 ;; clear screen
 (defun (clear-tiles2)
   ;; nametable 1
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 4 0 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 4 128 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 5 0 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 5 128 2)
   ;; nametable 2
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 6 0 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 6 128 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 7 0 2)
   (display-list-add-byte 128)
   (display-list-add-byte #xff)
   (display-list-end-packet command-tile-value 7 128 2))

 ;; draw a load of consecutive tiles from chr-rom directly
 (defun (draw-image x y sx sy loc)
   (set! i 0)
   (set! j (- sx 1))
   (while (< i sy)
     (set! start (<< i 4)) ;; * 16
     (set! end (+ start j))
     (loop n start end (display-list-add-byte (+ loc n)))
     (display-list-end-packet command-tile-data x (+ y (<< i 5)) sx) ;; * 32
     (inc i)))

 ;; draws a single page of prg-rom defined tiles
 (defun (draw-bg l h page)
   (set! h (+ h page))
   (display-list-add-byte (+ l 0))
   (display-list-add-byte h)
   (display-list-add-byte 64)
   (display-list-end-packet command-rom-data page 0 3)
   (display-list-add-byte (+ l 64))
   (display-list-add-byte h)
   (display-list-add-byte 64)
   (display-list-end-packet command-rom-data page 64 3)
   (display-list-add-byte (+ l 128))
   (display-list-add-byte h)
   (display-list-add-byte 64)
   (display-list-end-packet command-rom-data page 128 3)
   (display-list-add-byte (+ l 192))
   (display-list-add-byte h)
   (display-list-add-byte 64)
   (display-list-end-packet command-rom-data page 192 3))

 ;; draws an entire screens worth of prg-rom defined tiles
 (defun (draw-screen l h)
   (draw-bg (low bgtiles) (high bgtiles) 0)
   (draw-bg (low bgtiles) (high bgtiles) 1)
   (draw-bg (low bgtiles) (high bgtiles) 2)
   (draw-bg (low bgtiles) (high bgtiles) 3))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; text display

 ;; draw text straight to screen
 (defun (draw-text h l)
   ;; zero terminating strings
   (set! i 1) ;; char
   (set! j 0) ;; count
   (while (not (eq? i 0))
     (set! i (peek16 text-addr j))
     (display-list-add-byte i)
     (inc j))
   (display-list-end-packet command-tile-data h (+ l text-pos) j)
   )

 ;; gradually type text to screen
 (defun (update-typed-text h l)
   (inc text-time)
   (when (> text-time 10)
     (set! i (peek16 text-addr text-pos))
     ;; zero terminating strings
     (when (not (eq? i 0))
       (display-list-add-byte i)
       (display-list-end-packet command-tile-data h (+ l text-pos) 1)
       (inc text-pos))
     (set! text-time 0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; textbox for character chat

 ;; gtext-box is used both as activation and countdown
 ;; to avoid repeated activation when next to characters

 (defconst text-box-deactivated "#0")
 (defconst text-box-activated "#254")
 (defconst text-box-start-delay "#253")

 ;; create the text box
 (defun (show-textbox)   
   (when (eq? gtext-box text-box-deactivated)  ;; not shown already
     (set! text-pos 0)                         ;; reset typing pos
     (set! gtext-box  text-box-activated)))    ;; set to shown

 (defun (update-textbox)   
   (when (eq? gtext-box text-box-activated)   ;; shown activated
     (update-typed-text 2 76)  ;; update typing
     (when (pressed joypad-b)  ;; exit pressed
       (set! gdraw-phase 1)    ;; redraw background
       (set! gtext-box text-box-start-delay)))  ;; start countdown running
   ;; do the count down
   (when (and (< gtext-box text-box-activated) 
	      (not (eq? gtext-box text-box-deactivated))) 
     (dec gtext-box)))
 

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; sprite stuff
 
 ;; set up a 2x2 block meta sprite
 (defun (setup-character block id)
   (set-sprite-x! id 0)
   (set-sprite-y! id 0)
   (set-sprite-id! id block)
   (set-sprite-attr! id 0)

   (set-sprite-x! (+ 1 id) 8)
   (set-sprite-y! (+ 1 id) 0)
   (set-sprite-id! (+ 1 id) (+ 1 block))
   (set-sprite-attr! (+ 1 id) 0)

   (set-sprite-x! (+ 2 id) 0)
   (set-sprite-y! (+ 2 id) 8)
   (set-sprite-id! (+ 2 id) (+ 16 block))
   (set-sprite-attr! (+ 2 id) 0)

   (set-sprite-x! (+ 3 id) 8)
   (set-sprite-y! (+ 3 id) 8)
   (set-sprite-id! (+ 3 id) (+ 17 block))
   (set-sprite-attr! (+ 3 id) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; collisions: all assume 2x2 sprites...

 ;; sprites colliding against sprites
 (defun (sprite-collide-sprite sprite-id-a sprite-id-b)
   ;; collide with 4th sprite x/y as centre of 2x2
   (sprite-collide-pos 
    sprite-id-a 
    (get-sprite-x (+ sprite-id-b 3))
    (get-sprite-y (+ sprite-id-b 3))))
 
 ;; sprite pixel pos collision
 (defun (sprite-collide-pos sprite-id x y)
   (and 
    (and
     ;; expanding bbox to get edge-edge collision
     ;; can reduce this to get 'softer' collisions
     (> x (- (get-sprite-x sprite-id) 8))
     (< x (+ (get-sprite-x (+ sprite-id 1)) 16)))
    (and 
     (> y (- (get-sprite-y sprite-id) 8))
     (< y (+ (get-sprite-y (+ sprite-id 2)) 16)))))

 (defun (bb-collide-pos screen x y)
   (if (eq? screen 0)
       (bb-collide-pos-screen0 x y)
     (bb-collide-pos-screen1 x y)))
   
 ;; bounding box list collisions for level terrain
 ;; different directions use different hotspots
 ;; still some tweaks todo here
 (defun (bb-collide-pos-screen0 x y)
   ;; read the length of rects to get the end
   (set! end (+ 1 (<< (peek collision_bboxes0) 2))) ;; rect so * 4   
   ;; setup for the loop
   (set! i 1) ;; address
   (set! j 0) ;; return value (1=collision)
   ;; loop through all the collision rects (or until we are inside one)
   (while (and (< i end) (eq? j 0))
     (set! j
	   (and ;; check bounding boxes
	    (and
	     (> x (peek collision_bboxes0 i)) 
	     (< x (peek collision_bboxes0 (+ i 2))))
	    (and 
	     (> y (peek collision_bboxes0 (+ i 1)))
	     (< y (peek collision_bboxes0 (+ i 3))))))
     (set! i (+ i 4))) ;; next bbox
   j)

 (defun (bb-collide-pos-screen1 x y)
   ;; read the length of rects to get the end
   (set! end (+ 1 (<< (peek collision_bboxes1) 2))) ;; rect so * 4   
   ;; setup for the loop
   (set! i 1) ;; address
   (set! j 0) ;; return value (1=collision)
   ;; loop through all the collision rects (or until we are inside one)
   (while (and (< i end) (eq? j 0))
     (set! j
	   (and ;; check bounding boxes
	    (and
	     (> x (peek collision_bboxes1 i)) 
	     (< x (peek collision_bboxes1 (+ i 2))))
	    (and 
	     (> y (peek collision_bboxes1 (+ i 1)))
	     (< y (peek collision_bboxes1 (+ i 3))))))
     (set! i (+ i 4))) ;; next bbox
   j)

 ;; doors to other dimensions

 (defun (doorway-collide-pos x y)
   (and ;; check bounding boxes
    (and
     (> x (peek doorway_bbox i)) 
     (< x (peek doorway_bbox (+ i 2))))
    (and 
     (> y (peek doorway_bbox (+ i 1)))
     (< y (peek doorway_bbox (+ i 3))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; entity system

 (defconst entity-id "#0") ;; the sprite id
 (defconst entity-x "#1")
 (defconst entity-screen "#2") ;; the high byte of x
 (defconst entity-y "#3")
 (defconst entity-state "#4") ;; for whatever
 (defconst entity-size "#5")

 (defconst num-entities "#4")

 (defconst player-entity "#0")
 (defconst npc1-entity "#5")
 (defconst npc2-entity "#10")
 (defconst npc3-entity "#15")

 (defconst player-sprite "#0")

 (defconst player-sprite-pattern-id "#$00")
 (defconst dancer-sprite-pattern-id "#$c0")

 (defun (setup-npc-entity eaddr screen x y col)
   (set! n (peek entity-data (+ eaddr entity-id))) ;; entity/sprite id
   (setup-character dancer-sprite-pattern-id n)
   (or-sprites-attr! n 4 col)
   (poke! entity-data (+ eaddr entity-x) x)
   (poke! entity-data (+ eaddr entity-screen) screen)
   (poke! entity-data (+ eaddr entity-y) y))
 
 (defun (init-entities)
   (set! j 0)
   (loop i 0 num-entities
	 (poke! entity-data (+ j entity-id) (<< i 2)) ;; * 4 sprite id
	 (set! j (+ j entity-size)))

   (set! n (peek entity-data (+ player-entity entity-id)))
   (setup-character player-sprite-pattern-id n)
   (poke! entity-data (+ n entity-x) 35)
   (poke! entity-data (+ n entity-y) 100)
   
   (setup-npc-entity npc1-entity 0 200 170 10)
   (setup-npc-entity npc2-entity 0 220 140 11)
   (setup-npc-entity npc3-entity 1 170 100 01))

 ;; convert the logical 16bit entity positions into 
 ;; 8bit screen positions
 (defun (update-entities)
   (set! n 0) ;; entity addr
   (set! j 0) ;; sprite addr
   (set! i 0) ;; entity id
   (while (< i num-entities)
     (set! o (peek entity-data (+ n entity-x)))
     (set-sprites-2x2-x! j (- o gscroll-x))
     (set-sprites-2x2-y! j (- (peek entity-data (+ n entity-y)) gscroll-y))

     ;; clip left/right sides for npc's
     (when (> i 0)
       (if (eq? (peek entity-data (+ n entity-screen)) 0)
	   ;; move off the screen
	   (when (> gscroll-x o) (set-sprites-2x2-y! j 245))
	   (when (< gscroll-x (+ o 8)) (set-sprites-2x2-y! j 245))))

     (set! j (+ j 16)) ;; 4 sprites in bytes
     (set! n (+ n entity-size))
     (inc i)))

 (defun (entity-move-left addr)
   (set! i (peek entity-data (+ addr entity-x)))
   (set! j (peek entity-data (+ addr entity-screen)))
   (-16! i 0 1)
   (poke! entity-data (+ addr entity-x) i)
   (poke! entity-data (+ addr entity-screen) j))

 (defun (entity-move-right addr)
   (set! i (peek entity-data (+ addr entity-x)))
   (set! j (peek entity-data (+ addr entity-screen)))
   (+16! i 0 1)
   (poke! entity-data (+ addr entity-x) i)
   (poke! entity-data (+ addr entity-screen) j))

 (defun (entity-move-up addr)
   (poke! entity-data 
	  (+ addr entity-y) 
	  (- (peek entity-data (+ addr entity-y)) 1)))

 (defun (entity-move-down addr)
   (poke! entity-data 
	  (+ addr entity-y) 
	  (+ (peek entity-data (+ addr entity-y)) 1)))

 (defun (bb-collide-entity-left addr)
   (bb-collide-pos
    (peek entity-data (+ addr entity-screen))
    (peek entity-data (+ addr entity-x)) 
    (+ (peek entity-data (+ addr entity-y)) 8)))
      
 (defun (bb-collide-entity-right addr)
   ;; check 16 bit left/right
   (set! i (peek entity-data (+ addr entity-x)))
   (set! j (peek entity-data (+ addr entity-screen)))
   (+16! i 0 16) ;; add 16 to current x pos
   (bb-collide-pos 
    j ;; screen id
    i (+ (peek entity-data (+ addr entity-y)) 8)))
   
 (defun (bb-collide-entity-up addr)
   (bb-collide-pos 
    (peek entity-data (+ addr entity-screen))
    (+ (peek entity-data (+ addr entity-x)) 8)
    (peek entity-data (+ addr entity-y))))

 (defun (bb-collide-entity-down addr)
   (bb-collide-pos 
    (peek entity-data (+ addr entity-screen))
    (+ (peek entity-data (+ addr entity-x)) 8)
    (+ (peek entity-data (+ addr entity-y)) 16)))

 (defun (doorway-collide-entity addr)
   (if (eq? (peek entity-data (+ addr entity-screen)) 1)
       (doorway-collide-pos 
	(+ (peek entity-data (+ addr entity-x)) 8)
	(+ (peek entity-data (+ addr entity-y)) 8))
     0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; game modes

 (defun (switch-game-mode new-mode)
   ;; clear all pending stuff in the queue
   (display-list-flush)
   ;; blank the screen to hide update
   (display-list-add-byte black-palette-id) 
   (display-list-end-packet command-palette-change 0 0 1)
   (set! ggame-mode new-mode)
   (set! text-pos 0)
   ;; reset the draw phase
   (set! gdraw-phase 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; game specific code follows
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 (defconst title-mode "#0")
 (defconst eighties-mode "#1")
 (defconst future-mode "#2")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; title

 (defun (update-title)
   (cond
    ((eq? gdraw-phase 1) 
     (mmc1-chrbank0 0)
     (mmc1-chrbank1 1)
     (update-sprites-title))
    ((eq? gdraw-phase 2)
     (draw-image 0 73 13 6 #x0)
     (clear-tiles)
     (set16! text-addr intropress))
    ;; wait before reveal
    ((eq? gdraw-phase screen-blank-delay)
     (display-list-add-byte title-palette-id) 
     (display-list-end-packet command-palette-change 0 0 1))
    ;; let clear happen first
    ((> gdraw-phase screen-blank-delay)
     (update-typed-text 1 73)))

   (when (or
	  (or (pressed joypad-a)
	      (pressed joypad-b))
	  (or
	   (pressed joypad-select)
	   0
					;(pressed joypad-start)
	   ))
     (switch-game-mode eighties-mode))
   )

 (defun (update-sprites-title)
   (memset sprite-shadow #xff))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; eighties

 (defun (init-sprites-eighties)
   ;; clear page #2, which we'll use to hold sprite data
   ;; (memset writes 256 bytes in one go)

   (when (eq? setup-eighties 0)
     (memset sprite-shadow #xff)
     (init-entities))
   (set! setup-eighties 1)
   
   (defvar direction 1)
   (defvar last-dir 1)
   
   )

 (defun (update-eighties) 
   (when (not (eq? gtext-box 255))
     (cond 
      ((eq? gdraw-phase 1) 
       (mmc1-chrbank0 2)
       (mmc1-chrbank1 3)
       (init-sprites-eighties))
      ;; separate phase so the textbox can redraw on clear
      ;; but leave the sprites where they are etc
      ((eq? gdraw-phase 2) 
       (draw-screen (low bgtiles) (high bgtiles))
       ;; try writing stuff to screen 2
       (display-list-add-byte 128)
       (display-list-add-byte #x17)
       (display-list-end-packet command-tile-value 4 0 2)

       (display-list-add-byte 6)
       (display-list-add-byte #x18)
       (display-list-end-packet command-tile-value 5 (+ 32 10) 2)
       (display-list-add-byte 6)
       (display-list-add-byte #x18)
       (display-list-end-packet command-tile-value 5 (+ 64 10) 2)

       (display-list-add-byte 3)
       (display-list-add-byte #x19)
       (display-list-end-packet command-tile-value 7 20 2)

       (clear-tiles2)

       )
      ;; wait before reveal
      ((eq? gdraw-phase screen-blank-delay)
       (display-list-add-byte eighties-palette-id) 
       (display-list-end-packet command-palette-change 0 0 1)))

     (when (not (eq? gtext-box text-box-activated))
       (update-sprites-eighties))

     (when (pressed joypad-start)
       (switch-game-mode title-mode)))

   (update-textbox))

 (defun (update-player player-sprite)
   ;; is the player character moving?
   (defvar running 1)
   (set! i 0)

   (when (pressed joypad-select)
     (set! i #x40))

   (cond
    ((pressed joypad-up)
     ;; set direction to be the sprite offset for the
     ;; (3 frame) animation start facing in this direction
     (set! direction (+ i #x26))
     (when (not (bb-collide-entity-up player-entity))
       (entity-move-up player-entity)))
    
    ((pressed joypad-down)
     (set! direction (+ i #x20))
     (when (not (bb-collide-entity-down player-entity))
       (entity-move-down player-entity)))

    ((pressed joypad-left)
     (set! direction (+ i #x0a))
     (when (not (bb-collide-entity-left player-entity))
       (entity-move-left player-entity)
       (when (or (and
		  (eq? (peek entity-data entity-screen) 0)
		  (> (peek entity-data entity-x) 127))
		 (and
		  (eq? (peek entity-data entity-screen) 1)
		  (< (peek entity-data entity-x) 127)))
	 (set! gscroll-x (- (peek entity-data entity-x) 127)))))
		 
    ((pressed joypad-right)
     (set! direction (+ i #x04))
     (when (not (bb-collide-entity-right player-entity))
       (entity-move-right player-entity)
       (when (or (and
		  (eq? (peek entity-data entity-screen) 0)
		  (> (peek entity-data entity-x) 127))
		 (and
		  (eq? (peek entity-data entity-screen) 1)
		  (< (peek entity-data entity-x) 127)))
	 (set! gscroll-x (- (peek entity-data entity-x) 127)))))
       
    (else
     ;; we are not moving
     (set! running 0)))

   ;; animate player character
   (when running 
     (cond 
      ((eq? (and (>> ganim-frame 3) #x3) 0)
       (animate-sprites-2x2! player-sprite direction))
      ((eq? (and (>> ganim-frame 3) #x3) 1)
       (animate-sprites-2x2! player-sprite (+ 2 direction)))
      (else
       (animate-sprites-2x2! player-sprite (+ 4 direction)))))

   (when (not running)
     (if (eq? last-dir (+ i #x0a)) ;; left
	 ;; standing
	 (animate-sprites-2x2! player-sprite #x2)
       (animate-sprites-2x2! player-sprite #x0)))
   
   (when running
     (set! last-dir direction)))

 (defun (update-npc id)
   ;; convert from entity id to sprite id
   (set! id (peek entity-data (+ id entity-id)))
   (when (sprite-collide-sprite player-sprite id)
     (cond 
      ((eq? (and (>> ganim-frame 3) #x3) 0)
       (animate-sprites-2x2! id dancer-sprite-pattern-id))
      ((eq? (and (>> ganim-frame 3) #x3) 1)
       (animate-sprites-2x2! id (+ dancer-sprite-pattern-id 2)))
      (else
       (animate-sprites-2x2! id (+ dancer-sprite-pattern-id 4))))))

 (defun (update-sprites-eighties)
   (update-player player-sprite)
   (update-npc npc1-entity)
   (update-npc npc2-entity)
   (update-npc npc3-entity)

   ;; get them to react to the player
   (when (sprite-collide-sprite 0 (peek entity-data (+ npc1-entity entity-id)))
     (set16! text-addr npcsays) ;; what to say
     (show-textbox))

   ;; exit to future level, but wait
   (when (and (eq? gdraw-phase 255) 
	      (doorway-collide-entity player-entity))
     (switch-game-mode future-mode))

   (update-entities)
   
   (inc ganim-frame)
   (when (> ganim-frame 23)
     (set! ganim-frame 0))


   )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; future

 (defun (fuzz)
   ;; random fuzz
   (display-list-add-byte (rnd)) 
   (display-list-end-packet 
    command-tile-data (and (rnd) #b00000111) 
    gframe 1))

 (defun (update-future)
   (cond
    ((eq? gdraw-phase 1) 
     (mmc1-chrbank0 4)
     (mmc1-chrbank1 5)
     (update-sprites-future))
    ((eq? gdraw-phase 2)
     (set16! text-addr futureblurb)
     ;;(draw-image 0 73 13 6 #x0)
     )
    ;; wait before reveal
    ((eq? gdraw-phase 20)
     (display-list-add-byte future-palette-id) 
     (display-list-end-packet command-palette-change 0 0 1))
    ;; let clear happen first
    ((> gdraw-phase 20)
     (fuzz)     
     (update-typed-text 6 68)
     ))
   
   (when (pressed joypad-select)
     (switch-game-mode eighties-mode))

   
   (update-sprites-future))

 (defun (update-sprites-future)
   0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; interrupts

 (defint (reset)
   (init-system)
   (disable-rendering)
   (init-sound)
   (enable-rendering)
   ;; clear sprite shadow
   (memset sprite-shadow #xff)
   ;; set mmc1 so we can update tiles/sprites separately
   ;; (using 4k blocks rather than 8k ones, mirror vertically)
   (mmc1-control #b00010010)

   ;; load first palette
   (display-list-add-byte black-palette-id) 
   (display-list-end-packet command-palette-change 0 0 1)

   (asm
    "cli"            ;; restart interrupts again
    "loop: jmp loop" ;; go into in infinite loop - vblank interrupt takes over
    ))

 ;; main loop is here
 (defint (vblank)
   ;; precious ppu update time starts
   ;; start sprite data dma to the oam now
   (set! reg-oam-dma sprite-dma)
   ;; dma the display list now
   (display-list-execute)

   ;; update scroll pos
   (set! reg-ppu-scroll gscroll-x)
   (set! reg-ppu-scroll gscroll-y)

   ;; precious ppu update time ends

   ;; profiling display (breaks sprite update)
   ;; (asm "
   ;; 	lda #%10001110	
   ;; 	sta $2001
   ;; ")

   ;; update whichever game mode we are in
   (cond
    ((eq? ggame-mode title-mode) (update-title))
    ((eq? ggame-mode eighties-mode) (update-eighties))    
    (else (update-future)))

   ;; read the joypad state into memory
   (read-joypad)
   (inc gframe)

   ;; increment the draw phase
   (when (not (eq? gdraw-phase 255)) 
     (inc gdraw-phase))

   ;; update sound driver
;;   (asm "jsr FamiToneUpdate")

   ;; (asm "
   ;; 	lda #%00001110
   ;; 	sta $2001
   ;;  ")
   
   )
 
 (defint (irq))
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; game data follows

 ;; text
 (asm "intropress:")(text "press any key") (byte "0")
 (asm "npcsays:")(text "hey, watch my moves")(byte "0")
 (asm "futureblurb:")(text "welcome to the future")(byte "0")

 ;; bounding box data
 (asm "collision_bboxes0")
 (byte "5") ;; number of boxes
 (byte "58, 90, 156, 155")
 (byte "80, 82, 173, 147")
 (byte "0, 0, 22, 238")
 (byte "0, 0, 255, 45")
 (byte "197, 0, 255, 91")

 (asm "collision_bboxes1")
 (byte "1") ;; number of boxes
 (byte "82, 71, 131, 90")


 (asm "doorway_bbox")
 (byte "160, 191, 184, 201")

 ;; screen tiles
 (asm ".align $100") ;; align so we don't need 16 address maths!
 (asm "bgtiles:")
 (byte "9, 10, 28, 27, 28, 27, 28, 27, 28, 15, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 79, 59, 41, 41, 41, 41, 41, 41, 25, 70, 12, 4, 4, 11, 12, 11, 12, 15, 11, 12, 11, 12, 11, 12, 11, 12, 11, 12, 11, 12, 11, 12, 15, 4, 4, 4, 4, 5, 6, 4, 3, 70, 28, 5, 6, 27, 28, 27, 28, 15, 27, 28, 27, 28, 27, 28, 27, 28, 27, 28, 27, 28, 27, 28, 15, 11, 12, 11, 12, 21, 22, 11, 3, 70, 19, 21, 22, 19, 19, 19, 19, 47, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 15, 27, 28, 27, 28, 45, 46, 27, 41, 42, 3, 3, 3, 3, 3, 3, 3, 3, 11, 12, 11, 12, 4, 4, 11, 12, 11, 12, 4, 4, 11, 12, 15, 4, 4, 4, 4, 61, 62, 4, 12, 3, 0, 1, 1, 1, 1, 1, 1, 2, 27, 28, 27, 28, 13, 14, 27, 28, 27, 28, 13, 14, 27, 28, 15, 11, 12, 11, 12, 61, 62, 11, 28, 3, 16, 39, 39, 39, 39, 39, 39, 18, 20, 19, 19, 19, 29, 30, 19, 19, 19, 19, 29, 30, 19, 19, 47, 27, 28, 27, 28, 45, 46, 27, 12, 3, 16, 39, 39, 39, 39, 39, 39, 38, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 7, 7, 7, 7, 61, 62, 7, 28, 3, 16, 39, 39, 39, 39, 39, 39, 39, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 11, 12, 11, 12, 45, 46, 11, 9, 9, 9, 76, 36, 39, 39, 39, 39, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 27, 28, 27, 28, 61, 62, 27, 3, 3, 25, 26, 16, 39, 39, 17, 17, 17, 75, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 76, 17, 17, 18, 20, 19, 19, 19, 61, 62, 4, 41, 41, 41, 42, 16, 39, 39, 75, 9, 9, 58, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 26, 17, 17, 38, 1, 1, 1, 1, 37, 38, 2, 12, 11, 12, 3, 16, 39, 39, 24, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 56, 127, 41, 44, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 28, 27, 28, 3, 16, 39, 39, 43, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 60, 94, 12, 36, 17, 17, 35, 33, 33, 33, 33, 33, 33, 34, 12, 11, 12, 3, 16, 39, 39, 17, 11, 12, 11, 12, 11, 12, 11, 12, 11, 12, 4, 110, 28, 16, 17, 17, 18, 3, 3, 3, 3, 3, 3, 3")
 (byte "28, 27, 28, 3, 16, 39, 39, 35, 27, 28, 27, 28, 27, 28, 27, 28, 27, 28, 4, 94, 12, 16, 17, 17, 18, 3, 3, 3, 3, 3, 3, 3, 13, 14, 4, 3, 16, 39, 39, 18, 11, 12, 11, 12, 4, 4, 11, 12, 11, 12, 4, 110, 28, 16, 17, 17, 18, 3, 3, 3, 3, 3, 3, 3, 29, 30, 23, 3, 16, 39, 39, 18, 27, 28, 27, 28, 5, 6, 27, 28, 27, 28, 4, 63, 23, 16, 17, 17, 18, 3, 3, 3, 3, 3, 3, 3, 10, 3, 3, 3, 16, 39, 39, 18, 20, 19, 19, 19, 21, 22, 19, 19, 19, 19, 23, 0, 1, 37, 17, 17, 38, 1, 2, 3, 3, 3, 3, 3, 70, 0, 1, 1, 37, 39, 39, 38, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 37, 17, 17, 17, 17, 17, 17, 38, 1, 2, 3, 3, 3, 70, 16, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 17, 17, 17, 17, 17, 17, 17, 17, 38, 1, 1, 1, 70, 16, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 74, 9, 76, 39, 39, 39, 35, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 36, 39, 39, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 3, 3, 26, 39, 39, 39, 38, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 37, 39, 39, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 127, 41, 44, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 17, 17, 17, 17, 17, 17, 35, 33, 33, 33, 94, 12, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 36, 39, 39, 17, 17, 17, 17, 17, 35, 34, 3, 3, 3, 110, 28, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 32, 33, 36, 17, 17, 17, 35, 33, 34, 3, 3, 3, 3, 94, 12, 3, 3, 3, 3, 3, 3, 3, 75, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 3, 32, 33, 33, 33, 34, 3, 3, 3, 3, 3, 3, 110, 28, 3, 3, 3, 3, 3, 3, 3, 71, 3, 3, 3, 3, 3, 3, 3, 3, 3, 70, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 9, 9, 9, 9, 9, 9, 9, 10, 3, 71, 3, 3, 3, 3, 3, 3, 3, 3, 3, 70, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3")

 ;; sound code
 (asm ".include \"famitone2_asm6.asm\"")
 (asm ".include \"danger_streets.asm\"")

 ;; the palettes
 (asm "title_palette:")

 (byte "$11,$21,$31,$30")
 (byte "$11,$21,$31,$30")
 (byte "$11,$21,$31,$30")
 (byte "$11,$14,$20,$2c")

 (byte "$11,$21,$31,$30")
 (byte "$13,$23,$33,$30")
 (byte "$15,$25,$35,$30")
 (byte "$17,$27,$37,$30")

 (asm "eighties_palette:")

 (byte "$11,$21,$31,$30")
 (byte "$11,$21,$31,$30")
 (byte "$11,$21,$31,$30")
 (byte "$11,$21,$31,$30")

 (byte "$11,$21,$31,$30")
 (byte "$13,$23,$33,$30")
 (byte "$15,$25,$35,$30")
 (byte "$17,$27,$37,$30")

 (asm "future_palette:")

 (byte "$01,$02,$03,$04")
 (byte "$41,$22,$21,$30")
 (byte "$11,$21,$31,$30")
 (byte "$14,$22,$42,$90")

 (byte "$31,$02,$03,$04")
 (byte "$51,$72,$91,$30")
 (byte "$51,$91,$81,$40")
 (byte "$64,$72,$32,$43")

 (asm "black_palette:")

 (byte "$0f,$0f,$0f,$0f")
 (byte "$0f,$0f,$0f,$0f")
 (byte "$0f,$0f,$0f,$0f")
 (byte "$0f,$0f,$0f,$0f")

 (byte "$0f,$0f,$0f,$0f")
 (byte "$0f,$0f,$0f,$0f")
 (byte "$0f,$0f,$0f,$0f")
 (byte "$0f,$0f,$0f,$0f")

 ;; dmc samples
					;(asm "	.org $c000
					;	.incbin \"after_the_rain.dmc\"")
 

 ;; interrupt vectors (addresses for functions)
 (asm ".pad $fffa") ;; jump to the end of prg-rom
 (asm ".word vblank, reset, irq")

 ;; finally ppu-rom 
 (asm 
  ".incbin \"binary/whatremains-title-tiles.chr\""
  ".align $1000"
  ".incbin \"binary/whatremains-title-sprites.chr\""
  ".align $1000")

 (asm 
  ".incbin \"binary/whatremains-eighties-tiles.chr\""
  ".align $1000"
  ".incbin \"binary/whatremains-eighties-sprites.chr\""
  ".align $1000")
 
 (asm 
  ".incbin \"binary/whatremains-future-tiles.chr\""
  ".align $1000"
  ".incbin \"binary/whatremains-future-sprites.chr\""
  ".align $1000")
 


 )
