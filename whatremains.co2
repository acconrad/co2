;; -*- mode: lisp; -*-
;; What Remains 
;; Copyright (C) 2016 What Remains Entertainment Consortium
;;
;; Licence TBD

(do
 ;; NES header follows
 (asm
  ".byte \"NES\",$1a" ;; number of prg-rom blocks
  ".byte $01" ;; number of chr-rom blocks
  ".byte $01" ;; rom control bytes: horizontal mirroring, no sram or trainer, mapper #0
  ".byte $00,$00" ;; filler
  ".byte $00,$00,$00,$00,$00,$00,$00,$00")

    ;; our memory layout
 (defconst sprite-shadow  "$200") ;; where the sprite control data is
 (defconst sprite-dma   "#$2") ;; dma address is 100X this = $200
 (defconst display-list "$300") ;; the display list
 (defconst pad-data     "$400") ;; cache of the current pad state
 (defconst music-data "$500")

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; display primitives
 ;; ------------------
 ;;
 ;; 
 ;; tile-data display primitive: [list of bytes to copy as tile ids]
 (defconst prim-tile-data "#$01")
 ;; tile-value display primitive: [length tile-id] 
 ;; for clearing screen etc - 128 long is about max for timing
 (defconst prim-tile-value "#$02")
 ;; 2x2 tile quad [tile top left id]
 (defconst prim-quad "#$03")

 ;; code start
 (org #xc000)
 
 ;; globals that will be removed - honest gov
 (defvar gframe 0)
 (defvar ggame-mode 0)
 (defvar gdraw-phase 0)
 
 ;; the current display list index 
 (defvar display-list-index 0)

 ;; random locals for use anywhere
 (defvar n 0)
 (defvar i 0)
 (defvar j 0)
 (defvar k 0)
 (defvar l 0)
 (defvar m 0)
 (defvar o 0)
 (defvar p 0)
 (defvar start 0)
 (defvar end 0)

 (defvar text-pos 0)
 (defvar text-time 0) 
 (defvar text-addr-h 0)
 (defvar text-addr-l 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; library code follows

 ;; really crappy random number generator
 (defun (rnd) (_rnd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; sound

(defun (init-sound)
  (set! reg-apu-channel #b00011111)

  (poke! music-data 0 #b11111101)
  (poke! music-data 2 #b11111110)
  (poke! music-data 5 #b11101110)
  (poke! music-data 10 #b11101010)
  (poke! music-data 12 #b11101010)
  (poke! music-data 14 #b11001010)
  (poke! music-data 15 #b11101011)

  (loop n 0 8 (poke! music-data (+ 16 (<< n 1)) #b00001111))
  )

(defun (play-p2 note)
  (set! reg-apu-pulse2-control #b10011111)
  (set! reg-apu-pulse2-ft note)
  (set! reg-apu-pulse2-ct #b11111000))

(defun (play-p1 note)
  (set! reg-apu-pulse1-control #b10011111)
  (set! reg-apu-pulse1-ft note)
  (set! reg-apu-pulse1-ct #b11111000))

(defun (play-n note)
  (set! reg-apu-noise-env #b10111111)
  (set! reg-apu-noise-ft note)
  (set! reg-apu-noise-ct #b00000000))

(defun (update-music)
  (when (and (>> gframe 3) 1)
    (play-p1 (peek music-data (+ 8 (and (>> gframe 4) #x0f))))
    (play-p2 (peek music-data (and (>> gframe 4) #x0f)))
    (play-n (peek music-data (+ 16 (and (>> gframe 4) #x0f))))
    ;; don't play the same thing twice
    ;;(poke! music-data (and (>> gframe 4) #x0f) (rnd))
    ;(poke! music-data (+ 16 (and (>> gframe 4) #x0f) (rnd)))
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; input stuff

 (defun (read-joypad)
   ;; need to 'strobe' register before reading
   (set! reg-joypad-0 1)
   (set! reg-joypad-0 0)
   (loop n 0 8
         (poke! pad-data n (and (peek reg-joypad-0) #x1))))

 (defun (pressed key)
   (peek pad-data key))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ppu transfers

 (defun (load-palette)
   ;; copy 32 bytes of bg and sprite palette
   (ppu-memcpy ppu-palette 0 0 #x20 palette 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; display list

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; display list

(defun (display-list-add-byte data)
  (poke! display-list display-list-index data) 
  (inc display-list-index))

(defun (display-list-end-packet prim-id x y nbytes)
  (poke! display-list display-list-index prim-id) 
  (inc display-list-index)
  (poke! display-list display-list-index x)
  (inc display-list-index)
  (poke! display-list display-list-index y)
  (inc display-list-index)
  ;; last byte needs to be size for all primitives
  (poke! display-list display-list-index nbytes) 
  (inc display-list-index))

(defun (display-list-execute)
  ;; is there anything in the queue?
  (if (eq? display-list-index 0) 0 ;; early out (avoid long branch)
    (do
     ;; reverse to read info (lifo for ease/speed)
     (set! display-list-index (- display-list-index 4))

     (set! n (peek display-list (+ display-list-index 3))) ;; store nbytes
     (set! start (- display-list-index n))
     (set! end display-list-index)

     ;; update tile data
     (when (eq? (peek display-list display-list-index) prim-tile-data) 
       (set! end display-list-index)
       (ppu-memcpy ppu-name-table-0 
		   (peek display-list (+ display-list-index 1)) 
		   (peek display-list (+ display-list-index 2))
		   end ;; w
		   display-list
		   start)) ;; start

     ;; update arbitrary length strips of one value (RLE)
     (when (eq? (peek display-list display-list-index) prim-tile-value) ;; tileset
       (ppu-memset ppu-name-table-0 
		   (peek display-list (+ display-list-index 1)) 
		   (peek display-list (+ display-list-index 2))
		   (peek display-list start) ;; length
		   (peek display-list (+ start 1)))) ;; tile id
     
     (when (eq? (peek display-list display-list-index) prim-quad) 
       (set! o (peek display-list (+ display-list-index 1)))
       (set! p (peek display-list (+ display-list-index 2)))
       (set! i (peek display-list start))
       ;; could be optimised a lot
       (ppu-memset ppu-name-table-0 o p 1 i) 
       (ppu-memset ppu-name-table-0 o (+ p 1) 1 (+ i 1)) 
       (ppu-memset ppu-name-table-0 o (+ p 32) 1 (+ i 16)) 
       (ppu-memset ppu-name-table-0 o (+ p 33) 1 (+ i 17))
       )
     
     (set! display-list-index (- display-list-index n)))))

(defun (clear-tiles)
  ; nametable 1
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 0 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 0 128 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 1 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 1 128 2)
  ; nametable 2
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 2 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 2 128 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 3 0 2)
  (display-list-add-byte 64)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 3 128 2))

(defun (display-8x4-image x y loc)
  (set! i 0)
  (while (< i 4)
    (set! start (<< i 4)) ;; * 16
    (set! end (+ start 7))
    (loop n start end (display-list-add-byte (+ loc n)))
    (display-list-end-packet prim-tile-data x (+ y (<< i 5)) 8) ;; * 32
    (inc i)))

(defun (display-6x4-image x y loc)
  (set! i 0)
  (while (< i 4)
    (set! start (<< i 4)) ;; * 16
    (set! end (+ start 5))
    (loop n start end (display-list-add-byte (+ loc n)))
    (display-list-end-packet prim-tile-data x (+ y (<< i 5)) 6) ;; * 32
    (inc i)))

 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; image display

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; text display

(defun (update-text)
  (inc text-time)
  (when (> text-time 10)
    (display-list-add-byte (peek mystring text-pos))
    (display-list-end-packet prim-tile-data 0 text-pos 1)
    (inc text-pos)
    (set! text-time 0))
  ;; reset
  (when (> text-pos 31)
    (set! text-pos 0)
    (loop n 0 33 (display-list-add-byte 0))
    (display-list-end-packet prim-tile-data 0 text-pos 34)))
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; sprite stuff
 
 ;; 2x2 block sprites
 (defun (setup-character block id)
   (set-sprite-x! id 0)
   (set-sprite-y! id 0)
   (set-sprite-id! id (+ 1 block))

   (set-sprite-x! (+ 1 id) 8)
   (set-sprite-y! (+ 1 id) 0)
   (set-sprite-id! (+ 1 id) (+ 2 block))

   (set-sprite-x! (+ 2 id) 0)
   (set-sprite-y! (+ 2 id) 8)
   (set-sprite-id! (+ 2 id) (+ 17 block))

   (set-sprite-x! (+ 3 id) 8)
   (set-sprite-y! (+ 3 id) 8)
   (set-sprite-id! (+ 3 id) (+ 18 block)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; collisions: all assume 2x2 sprites...

;; sprites colliding against sprites
(defun (sprite-collide-sprite sprite-id-a sprite-id-b)
  ;; collide with 4th sprite x/y as centre of 2x2
  (sprite-collide-pos 
   sprite-id-a 
   (get-sprite-x (+ sprite-id-b 3))
   (get-sprite-y (+ sprite-id-b 3))))
  
;; sprite pixel pos collision
(defun (sprite-collide-pos sprite-id x y)
  (and 
   (and
    ;; expanding bbox to get edge-edge collision
    ;; can reduce this to get 'softer' collisions
    (> x (- (get-sprite-x sprite-id) 8))
    (< x (+ (get-sprite-x (+ sprite-id 1)) 16)))
   (and 
    (> y (- (get-sprite-y sprite-id) 8))
    (< y (+ (get-sprite-y (+ sprite-id 2)) 16)))))

;; bounding box list collisions for level terrain
;; different directions use different hotspots
;; still some tweaks todo here

(defun (bb-collide-sprite-left sprite-id)
  (set! sprite-id (+ sprite-id 2))
  (bb-collide-pos (get-sprite-x sprite-id) 
		  (get-sprite-y sprite-id)))

(defun (bb-collide-sprite-right sprite-id)
  (set! sprite-id (+ sprite-id 3))
  (bb-collide-pos (+ (get-sprite-x sprite-id) 8) 
		  (get-sprite-y sprite-id)))

(defun (bb-collide-sprite-up sprite-id)
  (set! sprite-id (+ sprite-id 1))
  (bb-collide-pos (get-sprite-x sprite-id) 
		  (get-sprite-y sprite-id)))

(defun (bb-collide-sprite-down sprite-id)
  (set! sprite-id (+ sprite-id 3))
  (bb-collide-pos (get-sprite-x sprite-id) 
		  (+ (get-sprite-y sprite-id) 8)))

(defun (bb-collide-pos x y)
  ;; read the length of rects to get the end
  (set! end (+ 1 (<< (peek collision_data) 2))) ;; rect so * 4   
  ;; setup for the loop
  (set! i 1) ;; address
  (set! j 0) ;; return value (1=collision)
  ;; loop through all the collision rects (or until we are inside one)
  (while (and (< i end) (eq? j 0))
    (set! j
	  (and ;; check bounding boxes
	   (and
	    (> x (peek collision_data i)) 
	    (< x (peek collision_data (+ i 2))))
	   (and 
	    (> y (peek collision_data (+ i 1)))
	    (< y (peek collision_data (+ i 3))))))
    (set! i (+ i 4))) ;; next bbox
  j)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; game modes

(defconst title-mode "#0")
(defconst eighties-mode "#1")
(defconst future-mode "#2")

(defun (switch-game-mode new-mode)
  (set! ggame-mode new-mode)
  (set! gdraw-phase 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; title

(defun (update-title)
  (cond
   ((eq? gdraw-phase 1) 
    (update-sprites-title))
   ((eq? gdraw-phase 2)
    (clear-tiles))
   (else
    (update-text)))

  (when (pressed joypad-b)
    (switch-game-mode eighties-mode))
  )

(defun (update-sprites-title)
  (memset sprite-shadow #x00))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; eighties

(defconst player-sprite "#0")
(defconst npc1-sprite "#4")
(defconst npc2-sprite "#8")
(defconst npc3-sprite "#12")

(defun (init-sprites-eighties)
   ;; clear page #2, which we'll use to hold sprite data
   ;; (memset writes 256 bytes in one go)
   (memset sprite-shadow #x00)
   
   (setup-character #x0 player-sprite)
   
   (setup-character #x0 npc1-sprite)
   (add-sprites-x! npc1-sprite 4 100)
   (add-sprites-y! npc1-sprite 4 100)
   (or-sprites-attr! npc1-sprite 4 10)
   
   (setup-character #x70 npc2-sprite)
   (add-sprites-x! npc2-sprite 4 120)
   (add-sprites-y! npc2-sprite 4 80)
   (or-sprites-attr! npc2-sprite 4 11)
   
   (setup-character #x50 npc3-sprite)
   (add-sprites-x! npc3-sprite 4 70)
   (add-sprites-y! npc3-sprite 4 120)
   (or-sprites-attr! npc3-sprite 4 01)
   
   (defvar direction 1)
   
   )

(defun (update-eighties) 
  (cond
   ((eq? gdraw-phase 1) 
    (init-sprites-eighties))
   ((eq? gdraw-phase 2)
    ;; display the first screen
    (display-6x4-image 0 66 #x80)
    (display-6x4-image 1 (+ 66 16) #x80)
    (display-8x4-image 2 66 #x88)
    ;; (display list in reverse order)
    (clear-tiles))
   (else (update-sprites-eighties)))

  (when (pressed joypad-start)
    (switch-game-mode title-mode))
  
  )

(defun (update-sprites-eighties)
   ;; is the player character moving?
   (defvar running 1)

   (cond
    ((pressed joypad-up)
     ;; set direction to be the sprite offset for the
     ;; (2 frame) animation start facing in this direction
     (set! direction 5)
     ;; move the 4 sprites a bit
     (when (not (bb-collide-sprite-up player-sprite))
       (sub-sprites-y! player-sprite 4 1)))

    ((pressed joypad-down)
     (set! direction 1)
     (when (not (bb-collide-sprite-down player-sprite))
       (add-sprites-y! player-sprite 4 1)))

    ((pressed joypad-left)
     (set! direction 9)
     (when (not (bb-collide-sprite-left player-sprite))
       (sub-sprites-x! player-sprite 4 1)))

    ((pressed joypad-right)
     (set! direction 13)
     (when (not (bb-collide-sprite-right player-sprite))
       (add-sprites-x! player-sprite 4 1)))

    (else
     ;; we are not moving
     (set! running 0)))

   ;; animate player character
   (if (and running (>> (and gframe #x08) 3))
       (animate-sprites-2x2! player-sprite direction)
       (animate-sprites-2x2! player-sprite (+ 2 direction)))

   ;; the NPC's
   ;; get them to react to the player
   (when (sprite-collide-sprite player-sprite npc1-sprite)
     (if (and gframe #x08) ;; animation speed
	 ;; offset to sprite, offset to pattern
	 (animate-sprites-2x2! npc1-sprite #x51)
         (animate-sprites-2x2! npc1-sprite #x53)))

   (when (sprite-collide-sprite player-sprite npc2-sprite)
     (if (and gframe #x08) ;; try different speeds
       (animate-sprites-2x2! npc2-sprite #x71)
       (animate-sprites-2x2! npc2-sprite #x73)))

   (when (sprite-collide-sprite player-sprite npc3-sprite)
     (if (and gframe #x08)
	 (animate-sprites-2x2! npc3-sprite #x51)
         (animate-sprites-2x2! npc3-sprite #x53)))

   )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; future

(defun (update-future)
  (update-sprites-future))

(defun (update-sprites-future)
  0)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; interrupts

 (defint (reset)
   (init-system)

   (init-sound)

   ;; disable all graphics.
   (set! reg-ppu-ctl 0)
   (set! reg-ppu-mask 0)
   (set! reg-ppu-scroll 0)
   (set! reg-ppu-scroll 0)
   ;; send stuff to the ppu here...


   (load-palette)

   ;; set basic ppu registers.  load background from $0000,
   ;; sprites from $1000, and the name table from $2000.
   (set! reg-ppu-ctl #b10001000)
   (set! reg-ppu-mask #b00011110)

   ;; clear sprite shadow
   (memset sprite-shadow #x00)

   (asm
    ;; restart interrupts again
    "cli"
    ;; go into in infinite loop - vblank interrupt takes over
    "loop: jmp loop"))


 ;; main loop is here
 (defint (vblank)
   ;; these need to go first!
   ;; start sprite data dma to the oam now
   (set! reg-oam-dma sprite-dma)
   ;; dma the display list now
   (display-list-execute)

   ;; that's done, now we're safe to do whatever
   (cond
    ((eq? ggame-mode title-mode) (update-title))
    ((eq? ggame-mode eighties-mode) (update-eighties))    
    (else (update-future)))

   ;; reads the joypad state into memory to save time
   ;; probably premature optimisation?
   (read-joypad)
   (inc gframe)
   (when (not (eq? gdraw-phase 255)) (inc gdraw-phase))
   )
   
 (defint (irq))
 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; data follows

(asm "introtext:")
;       xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(text "What remains intro!")


(asm "mystring:")
;       xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(text " What remains? TESTING text 12345")

;; bounding box data follows
 (asm "collision_data")
 (byte "2") ;; number of boxes
 (byte "16,16,64,48")
 (byte "144,80,192,112")
 
 ;; stuff still to tidy up follows...
 (asm "palette:")

 (byte "$11,$21,$31,$30")
 (byte "$11,$21,$31,$30")
 (byte "$11,$21,$31,$30")
 (byte "$11,$21,$31,$30")

 (byte "$11,$21,$31,$30")
 (byte "$13,$23,$33,$30")
 (byte "$15,$25,$35,$30")
 (byte "$17,$27,$37,$30")

 (asm "bg:")
 ;; attribute table
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00")
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00")
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0")
 (byte "$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f")
 (asm ".pad $fffa")

;; interrupt vectors (addresses for functions)
 (asm ".word vblank, reset, irq")

 ;; finally all the chr data
 (asm 
  ".incbin \"binary/whatremains-tiles.chr\""
  ".align $1000"
  ".byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00" ; character 0: blank
  ".incbin \"binary/sprites.chr\""
  ".align $1000")
 
 )
