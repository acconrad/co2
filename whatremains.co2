;; -*- mode: lisp; -*-
;; What Remains 
;; Copyright (C) 2016 What Remains Entertainment Consortium
;;
;; Licence TBD

(do
 ;; NES header follows
 (asm
  ".byte \"NES\",$1a" ;; number of prg-rom blocks
  ".byte $01" ;; number of chr-rom blocks
  ".byte $01" ;; rom control bytes: horizontal mirroring, no sram or trainer, mapper #0
  ".byte $00,$00" ;; filler
  ".byte $00,$00,$00,$00,$00,$00,$00,$00")

    ;; our memory layout
 (defconst sprite-shadow  "$200") ;; where the sprite control data is
 (defconst sprite-dma   "#$2") ;; dma address is 100X this = $200
 (defconst display-list "$300") ;; the display list
 (defconst pad-data     "$400") ;; cache of the current pad state
 (defconst music-data "$500")

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; display primitives
 ;; ------------------
 ;;
 ;; 
 ;; tile-data display primitive: [list of bytes to copy as tile ids]
 (defconst prim-tile-data "#$01")
 ;; tile-value display primitive: [length tile-id] 
 ;; for clearing screen etc - 128 long is about max for timing
 (defconst prim-tile-value "#$02")

 ;; code start
 (org #xc000)

 ;; globals that will be removed - honest gov
 (defvar gframe 0)

 ;; the current display list index 
 (defvar display-list-index 0)

 ;; for use as temporaries (careful not to use them over fncalls
 ;; as they will get clobbered)
 (defvar n 0)
 (defvar i 0)
 (defvar j 0)
 (defvar k 0)
 (defvar l 0)
 (defvar start 0)
 (defvar end 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; library code follows

 ;; really crappy random number generator
 (defun (rnd) (_rnd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; sound

(defun (init-sound)
  (set! reg-apu-channel #b00011111)

  (poke! music-data 0 #b11111101)
  (poke! music-data 2 #b11111110)
  (poke! music-data 5 #b11101110)
  (poke! music-data 10 #b11101010)
  (poke! music-data 12 #b11101010)
  (poke! music-data 14 #b11001010)
  (poke! music-data 15 #b11101011)

  (loop n 0 8 (poke! music-data (+ 16 (<< n 1)) #b00001111))
  )

(defun (play-p2 note)
  (set! reg-apu-pulse2-control #b10011111)
  (set! reg-apu-pulse2-ft note)
  (set! reg-apu-pulse2-ct #b11111000))

(defun (play-p1 note)
  (set! reg-apu-pulse1-control #b10011111)
  (set! reg-apu-pulse1-ft note)
  (set! reg-apu-pulse1-ct #b11111000))

(defun (play-n note)
  (set! reg-apu-noise-env #b10111111)
  (set! reg-apu-noise-ft note)
  (set! reg-apu-noise-ct #b00000000))

(defun (update-music)
  (when (and (>> gframe 3) 1)
    (play-p1 (peek music-data (+ 8 (and (>> gframe 4) #x0f))))
    (play-p2 (peek music-data (and (>> gframe 4) #x0f)))
    (play-n (peek music-data (+ 16 (and (>> gframe 4) #x0f))))
    ;; don't play the same thing twice
    ;;(poke! music-data (and (>> gframe 4) #x0f) (rnd))
    ;(poke! music-data (+ 16 (and (>> gframe 4) #x0f) (rnd)))
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; input stuff

 (defun (read-joypad)
   ;; need to 'strobe' register before reading
   (set! reg-joypad-0 1)
   (set! reg-joypad-0 0)
   (loop n 0 8
         (poke! pad-data n (and (peek reg-joypad-0) #x1))))

 (defun (pressed key)
   (peek pad-data key))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ppu transfers

 (defun (load-palette)
   ;; copy 32 bytes of bg and sprite palette
   (ppu-memcpy ppu-palette 0 0 #x20 palette 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; display list

(defun (display-list-add-byte data)
  (poke! display-list display-list-index data) 
  (inc display-list-index))

(defun (display-list-end-packet prim-id x y nbytes)
  (poke! display-list display-list-index prim-id) 
  (inc display-list-index)
  (poke! display-list display-list-index x)
  (inc display-list-index)
  (poke! display-list display-list-index y)
  (inc display-list-index)
  ;; last byte needs to be size for all primitives
  (poke! display-list display-list-index nbytes) 
  (inc display-list-index))

(defun (display-list-execute)
  ;; is there anything in the queue?
  (if (eq? display-list-index 0) 0 ;; early out (avoid long branch)
    (do
     ;; reverse to read info (lifo for ease/speed)
     (set! display-list-index (- display-list-index 4))

     (set! n (peek display-list (+ display-list-index 3))) ;; store nbytes

     ;; update tile data
     (when (eq? (peek display-list display-list-index) prim-tile-data) 
       (set! start (- display-list-index n))
       (set! end display-list-index)
       (ppu-memcpy ppu-name-table-0 
		   (peek display-list (+ display-list-index 1)) ;; x
		   (peek display-list (+ display-list-index 2)) ;; y
		   end ;; w
		   display-list
		   start)) ;; start

     ;; update arbitrary length strips of one value (RLE)
     (when (eq? (peek display-list display-list-index) prim-tile-value) ;; tileset
       (set! start (- display-list-index n))
       (ppu-memset ppu-name-table-0 
		   (peek display-list (+ display-list-index 1)) ;; x
		   (peek display-list (+ display-list-index 2)) ;; y
		   (peek display-list start) ;; length
		   (peek display-list (+ start 1)))) ;; tile id
     (set! display-list-index (- display-list-index n)))))

(defun (clear-tiles)
  ; nametable 1
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 0 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 0 128 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 1 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 1 128 2)
  ; nametable 2
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 2 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 2 128 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 3 0 2)
  (display-list-add-byte 64)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 3 128 2))

(defun (display-8x4-image x y loc)
  (set! j loc) (set! k x) (set! l y) ;; store to prevent clobbering
  (set! i 0)
  (while (< i 4)
    (set! start (<< i 4)) ;; * 16
    (set! end (+ start 7))
    (loop n start end (display-list-add-byte (+ j n)))
    (display-list-end-packet prim-tile-data k (+ l (<< i 5)) 8) ;; * 32
    (inc i)))

 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; image display

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; text display

 ;; (defun (update-text)
 ;;   (inc text-time)
 ;;   (when (> text-time 10)
 ;;     (poke! tile-data text-pos (peek mystring text-pos))
 ;;     (inc text-pos)
 ;;     (set! text-time 0))
 ;;   ;; reset
 ;;   (when (> text-pos 32)
 ;;     (set! text-pos 0)
 ;;     (loop n 0 32
 ;; 	   (poke! tile-data n 0))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; sprite stuff
 
 ;; 2x2 block sprites
 (defun (setup-character block id)
   (set-sprite-x! id 0)
   (set-sprite-y! id 0)
   (set-sprite-id! id (+ 1 block))

   (set-sprite-x! (+ 1 id) 8)
   (set-sprite-y! (+ 1 id) 0)
   (set-sprite-id! (+ 1 id) (+ 2 block))

   (set-sprite-x! (+ 2 id) 0)
   (set-sprite-y! (+ 2 id) 8)
   (set-sprite-id! (+ 2 id) (+ 17 block))

   (set-sprite-x! (+ 3 id) 8)
   (set-sprite-y! (+ 3 id) 8)
   (set-sprite-id! (+ 3 id) (+ 18 block)))

 (defun (init-sprites)
   ;; clear page #2, which we'll use to hold sprite data
   ;; (memset writes 256 bytes in one go)
   (memset sprite-shadow #xfe)

   (setup-character #x0 0)

   (setup-character #x0 4)
   (add-sprites-x! 4 4 100)
   (add-sprites-y! 4 4 100)
   (or-sprites-attr! 4 4 10)

   (setup-character #x70 8)
   (add-sprites-x! 8 4 130)
   (add-sprites-y! 8 4 80)
   (or-sprites-attr! 8 4 11)

   (setup-character #x50 12)
   (add-sprites-x! 12 4 70)
   (add-sprites-y! 12 4 120)
   (or-sprites-attr! 12 4 01)

   (defvar direction 1)
   
   )

 (defun (update-sprite)
   ;; do sprite stuff here.
   ;; reads the joypad state into memory to save time
   ;; probably premature optimisation
   (read-joypad)

   ;; is the player character moving?
   (defvar running 1)

   (cond
    ((pressed joypad-up)
     ;; set direction to be the sprite offset for the
     ;; (2 frame) animation start facing in this direction
     (set! direction 5)
     ;; move the 4 sprites a bit
     (sub-sprites-y! 0 4 1))
    ((pressed joypad-down)
     (set! direction 1)
     (add-sprites-y! 0 4 1))
    ((pressed joypad-left)
     (set! direction 9)
     (sub-sprites-x! 0 4 1))
    ((pressed joypad-right)
     (set! direction 13)
     (add-sprites-x! 0 4 1))
    (else
     ;; we are not moving
     (set! running 0)))

   ;; player character
   (if (and running (>> (and gframe #x08) 3))
       (animate-sprites-2x2! 0 direction)
       (animate-sprites-2x2! 0 (+ 2 direction)))

   ;; the NPC's
   (if (and gframe #x08) ;; animation speed
       ;; offset to sprite, offset to pattern
       (animate-sprites-2x2! 4 #x51)
       (animate-sprites-2x2! 4 #x53))

   (if (and gframe #x10) ;; try different speeds
       (animate-sprites-2x2! 8 #x71)
       (animate-sprites-2x2! 8 #x73))

   (if (and gframe #x20)
       (animate-sprites-2x2! 12 #x51)
       (animate-sprites-2x2! 12 #x53))

   )

(defun (random-image)
  (if (not (eq? (<< gframe 2) 100)) 0
    (do
     ;; test some text
     (loop n 0 12 (display-list-add-byte (peek mystring n)))
     (display-list-end-packet prim-tile-data 2 (rnd) 13)

     (set! n (and (rnd) #x03))
     (cond
      ((eq? n 0) (display-8x4-image 2 (rnd) #x80))
      ((eq? n 1) (display-8x4-image 2 (rnd) #x88))
      ((eq? n 2) (display-8x4-image 2 (rnd) #xc0))
      (else (display-8x4-image 2 (rnd) #xc8))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; interrupts

 (defint (reset)
   (init-system)

   (init-sound)

   ;; disable all graphics.
   (set! reg-ppu-ctl 0)
   (set! reg-ppu-mask 0)
   (set! reg-ppu-scroll 0)
   (set! reg-ppu-scroll 0)
   ;; send stuff to the ppu here...


   (load-palette)

   ;; set basic ppu registers.  load background from $0000,
   ;; sprites from $1000, and the name table from $2000.
   (set! reg-ppu-ctl #b10001000)
   (set! reg-ppu-mask #b00011110)

   ;; (set! i 0)
   ;; (while (< i 4)
   ;;   (set! start (<< i 4)) ;; * 16
   ;;   (set! end (+ start 7))
   ;;   (loop n start end (display-list-add-byte (+ #x80 n)))
   ;;   (display-list-end-packet #x01 0 (+ 2 (<< i 5)) 8) ;; * 32
   ;;   (inc i))
   
   ;; (loop n 0 15 (display-list-add-byte (+ #x80 n)))
   ;; (display-list-end-packet #x01 0 0 8)
   ;; (loop n 16 23 (display-list-add-byte (+ #x80 n)))
   ;; (display-list-end-packet #x01 0 32 8)
   ;; (loop n 32 39 (display-list-add-byte (+ #x80 n)))
   ;; (display-list-end-packet #x01 0 64 8)
   ;; (loop n 48 55 (display-list-add-byte (+ #x80 n)))
   ;; (display-list-end-packet #x01 0 96 8)


   (display-8x4-image 0 34 #x80)
   (display-8x4-image 0 51 #x88)
   (display-8x4-image 1 2 #xc0)
   (display-8x4-image 1 11 #xc8)

   (clear-tiles)

   (set! rnd-reg 123)

   (init-sprites)

   (asm
    ;; restart interrupts again
    "cli"
    ;; go into in infinite loop - vblank interrupt takes over
    "loop: jmp loop"))


 ;; main loop is here
 (defint (vblank)
   ;; these need to go first!
   ;; start sprite data dma to the oam
   (set! reg-oam-dma sprite-dma)
   (display-list-execute)

   ;; now we're safe...
   (update-sprite)
   (random-image)

   ;;(update-text)
   ;; reads the joypad state into memory to save time
   ;; probably premature optimisation
   (read-joypad)

   (update-music)

   (inc gframe))

 (defint (irq))
 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; data follows

 (asm "mystring:")
;       xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 (text " What remains? TESTING text 1234")
 
 ;; stuff still to tidy up follows...

 (asm "palette:")
 (byte "$38,$00,$00,$00,$00,$02,$03,$04,$01,$02,$03,$0c,$38,$27,$17,$0d")
 (byte "$38,$18,$28,$38,$0c,$1c,$2c,$3c,$03,$13,$23,$33,$09,$19,$29,$39")

 (asm "bg:")
  ;; attribute table
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00")
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00")
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0")
 (byte "$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f")
 (asm ".pad $fffa")

;; interrupt vectors (addresses for functions)
 (asm ".word vblank, reset, irq")

 ;; finally all the chr data
 (asm 
  ".incbin \"binary/tiles.chr\""
  ".align $1000"
  ".byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00" ; character 0: blank
  ".incbin \"binary/sprites.chr\""
  ".align $1000")
 
 )
