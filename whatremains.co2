;; -*- mode: lisp; -*-
;; What Remains 
;; Copyright (C) 2016 What Remains Entertainment Consortium
;;
;; Licence TBD

(do
 ;; NES header follows
 (asm
  ".byte \"NES\",$1a" ;; number of prg-rom blocks
  ".byte $02" ;; number of chr-rom blocks
  ".byte $01" ;; rom control bytes: horizontal mirroring, no sram or trainer, mapper #0
  ".byte $00,$00" ;; filler
  ".byte $00,$00,$00,$00,$00,$00,$00,$00")

    ;; our memory layout
 (defconst sprite-shadow  "$200") ;; where the sprite control data is
 (defconst sprite-dma   "#$2") ;; dma address is 100X this = $200
 (defconst display-list "$300") ;; the display list
 (defconst pad-data     "$400") ;; cache of the current pad state
 ;(defconst music-data "$500")

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; display primitives
 ;; ------------------
 ;;
 ;; 
 ;; tile-data display primitive: [list of bytes to copy as tile ids]
 (defconst prim-tile-data "#$01")
 ;; tile-value display primitive: [length tile-id] 
 ;; for clearing screen etc - 128 long is about max for timing
 (defconst prim-tile-value "#$02")
 ;; 2x2 tile quad [tile top left id]
 (defconst prim-quad "#$03")

 ;; famitone stuff
 (asm "FT_BASE_ADR = $0500 ;; page in the RAM used for FT2 variables, should be $xx00
       FT_TEMP = $70 ;; 3 bytes in zeropage used by the library as a scratchpad
       FT_DPCM_OFF = $c000  
       FT_SFX_STREAMS = 4 ;; number of sound effects played at once, 1..4
       FT_DPCM_ENABLE	;; undefine to exclude all DMC code
       FT_SFX_ENABLE	;; undefine to exclude all sound effects code
       FT_THREAD	;; undefine if you are calling sound effects from the same thread as the sound update call
       FT_PAL_SUPPORT   ;; undefine to exclude PAL support
       FT_NTSC_SUPPORT	;; undefine to exclude NTSC support
  ")

 ;; code start
 (org #x8000)

 (asm ".include \"famitone2_asm6.asm\"
        .include \"danger_streets.asm\"
;;.include \"after_the_rain.asm\"")
 
 ;; globals that will be removed - honest gov
 (defvar gframe 0)
 ;; stores what section of the game we are in, title/eighties/future
 (defvar ganim-frame 0)
 (defvar ggame-mode 0)
 ;; are we showing text?
 (defvar gtext-box 0)
 ;; ramps from 0-255 when game modes are switched, for sequencing
 ;; initialisation/drawlist updates for the big screen updates
 (defvar gdraw-phase 0)
 
 ;; the current display list index 
 (defvar display-list-index 0)

 ;; random locals for use anywhere
 (defvar n 0)
 (defvar i 0)
 (defvar j 0)
 (defvar k 0)
 (defvar l 0)
 (defvar m 0)
 (defvar o 0)
 (defvar p 0)
 (defvar start 0)
 (defvar end 0)

 (defvar text-pos 0)
 (defvar text-time 0) 
 (defvar text-addr 0)
 (defvar text-addr-h 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; library code follows

 ;; really crappy random number generator
 (defun (rnd) (_rnd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; sound

(defun (init-sound)
   (asm "ldx #<danger_streets_music_data	;play second song
   	ldy #>danger_streets_music_data
   	lda #80
   	jsr FamiToneInit
   	lda #0
   	jsr FamiToneMusicPlay")
   ;; (asm "ldx #<after_the_rain_music_data	;play second song
   ;; 	ldy #>after_the_rain_music_data
   ;; 	lda #80
   ;; 	jsr FamiToneInit
   ;; 	lda #0
   ;; 	jsr FamiToneMusicPlay")
   )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; input stuff

 (defun (read-joypad)
   ;; need to 'strobe' register before reading
   (set! reg-joypad-0 1)
   (set! reg-joypad-0 0)
   (loop n 0 8
         (poke! pad-data n (and (peek reg-joypad-0) #x1))))

 (defun (pressed key)
   (peek pad-data key))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ppu transfers

 (defun (load-palette)
   ;; copy 32 bytes of bg and sprite palette
   (ppu-memcpy ppu-palette 0 0 #x20 palette 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; display list

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; display list

(defun (display-list-add-byte data)
  (poke! display-list display-list-index data) 
  (inc display-list-index))

(defun (display-list-end-packet prim-id x y nbytes)
  (poke! display-list display-list-index prim-id) 
  (inc display-list-index)
  (poke! display-list display-list-index x)
  (inc display-list-index)
  (poke! display-list display-list-index y)
  (inc display-list-index)
  ;; last byte needs to be size for all primitives
  (poke! display-list display-list-index nbytes) 
  (inc display-list-index))

(defun (display-list-execute)
  ;; is there anything in the queue?
  (if (eq? display-list-index 0) 0 ;; early out (avoid long branch)
    (do
     ;; reverse to read info (lifo for ease/speed)
     (set! display-list-index (- display-list-index 4))

     (set! n (peek display-list (+ display-list-index 3))) ;; store nbytes
     (set! start (- display-list-index n))
     (set! end display-list-index)

     ;; update tile data
     (when (eq? (peek display-list display-list-index) prim-tile-data) 
       (set! end display-list-index)
       (ppu-memcpy ppu-name-table-0 
		   (peek display-list (+ display-list-index 1)) 
		   (peek display-list (+ display-list-index 2))
		   end ;; w
		   display-list
		   start)) ;; start

     ;; update arbitrary length strips of one value (RLE)
     (when (eq? (peek display-list display-list-index) prim-tile-value) ;; tileset
       (ppu-memset ppu-name-table-0 
		   (peek display-list (+ display-list-index 1)) 
		   (peek display-list (+ display-list-index 2))
		   (peek display-list start) ;; length
		   (peek display-list (+ start 1)))) ;; tile id
     
     (when (eq? (peek display-list display-list-index) prim-quad) 
       (set! o (peek display-list (+ display-list-index 1)))
       (set! p (peek display-list (+ display-list-index 2)))
       (set! i (peek display-list start))
       ;; could be optimised a lot
       (ppu-memset ppu-name-table-0 o p 1 i) 
       (ppu-memset ppu-name-table-0 o (+ p 1) 1 (+ i 1)) 
       (ppu-memset ppu-name-table-0 o (+ p 32) 1 (+ i 16)) 
       (ppu-memset ppu-name-table-0 o (+ p 33) 1 (+ i 17))
       )
     
     (set! display-list-index (- display-list-index n)))))

(defun (clear-tiles)
  ; nametable 1
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 0 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 0 128 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 1 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 1 128 2)
  ; nametable 2
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 2 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 2 128 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 3 0 2)
  (display-list-add-byte 64)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 3 128 2))

(defun (display-8x4-image x y loc)
  (set! i 0)
  (while (< i 4)
    (set! start (<< i 4)) ;; * 16
    (set! end (+ start 7))
    (loop n start end (display-list-add-byte (+ loc n)))
    (display-list-end-packet prim-tile-data x (+ y (<< i 5)) 8) ;; * 32
    (inc i)))

(defun (display-6x4-image x y loc)
  (set! i 0)
  (while (< i 4)
    (set! start (<< i 4)) ;; * 16
    (set! end (+ start 5))
    (loop n start end (display-list-add-byte (+ loc n)))
    (display-list-end-packet prim-tile-data x (+ y (<< i 5)) 6) ;; * 32
    (inc i)))

 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; image display

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; text display

(defun (draw-text h l)
  ;; zero terminating strings
  (set! i 1) ;; char
  (set! j 0) ;; count
  (while (not (eq? i 0))
    (set! i (peek16 text-addr j))
    (display-list-add-byte i)
    (inc j))
  (display-list-end-packet prim-tile-data h (+ l text-pos) j)
  )

(defun (update-typed-text h l)
  (inc text-time)
  (when (> text-time 10)
    (set! i (peek16 text-addr text-pos))
    ;; zero terminating strings
    (when (not (eq? i 0))
      (display-list-add-byte i)
      (display-list-end-packet prim-tile-data h (+ l text-pos) 1)
      (inc text-pos))
    (set! text-time 0)))
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; sprite stuff
 
 ;; 2x2 block sprites
 (defun (setup-character block id)
   (set-sprite-x! id 0)
   (set-sprite-y! id 0)
   (set-sprite-id! id block)
   (set-sprite-attr! id 0)

   (set-sprite-x! (+ 1 id) 8)
   (set-sprite-y! (+ 1 id) 0)
   (set-sprite-id! (+ 1 id) (+ 1 block))
   (set-sprite-attr! (+ 1 id) 0)

   (set-sprite-x! (+ 2 id) 0)
   (set-sprite-y! (+ 2 id) 8)
   (set-sprite-id! (+ 2 id) (+ 16 block))
   (set-sprite-attr! (+ 2 id) 0)

   (set-sprite-x! (+ 3 id) 8)
   (set-sprite-y! (+ 3 id) 8)
   (set-sprite-id! (+ 3 id) (+ 17 block))
   (set-sprite-attr! (+ 3 id) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; collisions: all assume 2x2 sprites...

;; sprites colliding against sprites
(defun (sprite-collide-sprite sprite-id-a sprite-id-b)
  ;; collide with 4th sprite x/y as centre of 2x2
  (sprite-collide-pos 
   sprite-id-a 
   (get-sprite-x (+ sprite-id-b 3))
   (get-sprite-y (+ sprite-id-b 3))))
  
;; sprite pixel pos collision
(defun (sprite-collide-pos sprite-id x y)
  (and 
   (and
    ;; expanding bbox to get edge-edge collision
    ;; can reduce this to get 'softer' collisions
    (> x (- (get-sprite-x sprite-id) 8))
    (< x (+ (get-sprite-x (+ sprite-id 1)) 16)))
   (and 
    (> y (- (get-sprite-y sprite-id) 8))
    (< y (+ (get-sprite-y (+ sprite-id 2)) 16)))))

;; bounding box list collisions for level terrain
;; different directions use different hotspots
;; still some tweaks todo here

(defun (bb-collide-sprite-left sprite-id)
  (set! sprite-id (+ sprite-id 2))
  (bb-collide-pos (get-sprite-x sprite-id) 
		  (get-sprite-y sprite-id)))

(defun (bb-collide-sprite-right sprite-id)
  (set! sprite-id (+ sprite-id 3))
  (bb-collide-pos (+ (get-sprite-x sprite-id) 8) 
		  (get-sprite-y sprite-id)))

(defun (bb-collide-sprite-up sprite-id)
  (set! sprite-id (+ sprite-id 1))
  (bb-collide-pos (get-sprite-x sprite-id) 
		  (get-sprite-y sprite-id)))

(defun (bb-collide-sprite-down sprite-id)
  (set! sprite-id (+ sprite-id 3))
  (bb-collide-pos (get-sprite-x sprite-id) 
		  (+ (get-sprite-y sprite-id) 8)))

(defun (bb-collide-pos x y)
  ;; read the length of rects to get the end
  (set! end (+ 1 (<< (peek collision_data) 2))) ;; rect so * 4   
  ;; setup for the loop
  (set! i 1) ;; address
  (set! j 0) ;; return value (1=collision)
  ;; loop through all the collision rects (or until we are inside one)
  (while (and (< i end) (eq? j 0))
    (set! j
	  (and ;; check bounding boxes
	   (and
	    (> x (peek collision_data i)) 
	    (< x (peek collision_data (+ i 2))))
	   (and 
	    (> y (peek collision_data (+ i 1)))
	    (< y (peek collision_data (+ i 3))))))
    (set! i (+ i 4))) ;; next bbox
  j)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; game modes

(defconst title-mode "#0")
(defconst eighties-mode "#1")
(defconst future-mode "#3")

(defun (switch-game-mode new-mode)
  (set! ggame-mode new-mode)
  (set! gdraw-phase 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; title

(defun (update-title)
  (cond
   ((eq? gdraw-phase 1) 
    (update-sprites-title))
   ((eq? gdraw-phase 2)
    (set16! text-addr introtitle)
    (draw-text 1 7)
    (clear-tiles)
    (set16! text-addr intropress))
   (else
    (update-typed-text 1 73)))

  (when (or
	 (or (pressed joypad-a)
	     (pressed joypad-b))
	 (or
	  (pressed joypad-select)
	  (pressed joypad-start)))
    (switch-game-mode eighties-mode))
  )

(defun (update-sprites-title)
  (memset sprite-shadow #xff))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; eighties

(defconst player-sprite "#0")
(defconst npc1-sprite "#4")
(defconst npc2-sprite "#8")
(defconst npc3-sprite "#12")

(defconst dancer-id "#$c0")

(defun (init-sprites-eighties)
   ;; clear page #2, which we'll use to hold sprite data
   ;; (memset writes 256 bytes in one go)
   (memset sprite-shadow #xff)
   
   (setup-character #x0 player-sprite)
   
   (setup-character dancer-id npc1-sprite)
   (add-sprites-x! npc1-sprite 4 100)
   (add-sprites-y! npc1-sprite 4 100)
   (or-sprites-attr! npc1-sprite 4 10)
   
   (setup-character dancer-id npc2-sprite)
   (add-sprites-x! npc2-sprite 4 120)
   (add-sprites-y! npc2-sprite 4 80)
   (or-sprites-attr! npc2-sprite 4 11)
   
   (setup-character dancer-id npc3-sprite)
   (add-sprites-x! npc3-sprite 4 70)
   (add-sprites-y! npc3-sprite 4 120)
   (or-sprites-attr! npc3-sprite 4 01)
   
   (defvar direction 1)
   (defvar last-dir 1)
   
   )

(defun (show-textbox)   
  (when (eq? gtext-box 0)
    (set! text-pos 0)
    (set! gtext-box 255))
  0)

(defun (update-textbox)   
  (when (eq? gtext-box 255)
    (update-typed-text 1 68)
    (when (pressed joypad-b)
      (set! gdraw-phase 1)
      (set! gtext-box 254))))

(defun (update-eighties) 
  (when (not (eq? gtext-box 255))
    (cond
     ((eq? gdraw-phase 1) 
      (init-sprites-eighties))
     ((eq? gdraw-phase 2) 
      ;; display the first screen
      (display-6x4-image 0 66 #x80)
      (display-6x4-image 1 (+ 66 16) #x80)
      (display-8x4-image 2 66 #x88)
      ;; (display list in reverse order)
      (clear-tiles))
     (else (update-sprites-eighties)))

    (when (pressed joypad-start)
      (switch-game-mode title-mode)))
  
  (when (and (< gtext-box 255) (> gtext-box 0)) (dec gtext-box))
  (update-textbox))

(defun (update-sprites-eighties)
   ;; is the player character moving?
   (defvar running 1)

   (set! i 0)

   (when (pressed joypad-select)
     (set! i #x40))

   (cond
    ((pressed joypad-up)
     ;; set direction to be the sprite offset for the
     ;; (3 frame) animation start facing in this direction
     (set! direction (+ i #x26))
     ;; move the 4 sprites a bit
     (when (not (bb-collide-sprite-up player-sprite))
       (sub-sprites-y! player-sprite 4 1)))

    ((pressed joypad-down)
     (set! direction (+ i #x20))
     (when (not (bb-collide-sprite-down player-sprite))
       (add-sprites-y! player-sprite 4 1)))

    ((pressed joypad-left)
     (set! direction (+ i #x0a))
     (when (not (bb-collide-sprite-left player-sprite))
       (sub-sprites-x! player-sprite 4 1)))

    ((pressed joypad-right)
     (set! direction (+ i #x04))
     (when (not (bb-collide-sprite-right player-sprite))
       (add-sprites-x! player-sprite 4 1)))

    (else
     ;; we are not moving
     (set! running 0)))

   ;; animate player character
   (when running 
     (cond 
      ((eq? (and (>> ganim-frame 3) #x3) 0)
       (animate-sprites-2x2! player-sprite direction))
      ((eq? (and (>> ganim-frame 3) #x3) 1)
       (animate-sprites-2x2! player-sprite (+ 2 direction)))
      (else
       (animate-sprites-2x2! player-sprite (+ 4 direction)))))

   (when (not running)
     (if (eq? last-dir (+ i #x0a)) ;; left
	 ;; standing
	 (animate-sprites-2x2! player-sprite #x2)
	 (animate-sprites-2x2! player-sprite #x0)))
       
   (when running
     (set! last-dir direction))

   ;; the NPC's
   ;; get them to react to the player
   (when (sprite-collide-sprite player-sprite npc1-sprite)
     (set16! text-addr npcsays)
     (show-textbox))

   (cond 
    ((eq? (and (>> ganim-frame 3) #x3) 0)
     (animate-sprites-2x2! npc1-sprite dancer-id))
    ((eq? (and (>> ganim-frame 3) #x3) 1)
     (animate-sprites-2x2! npc1-sprite (+ dancer-id 2)))
    (else
     (animate-sprites-2x2! npc1-sprite (+ dancer-id 4))))


   (when (sprite-collide-sprite player-sprite npc2-sprite)
     (cond 
      ((eq? (and (>> ganim-frame 3) #x3) 0)
       (animate-sprites-2x2! npc2-sprite dancer-id))
      ((eq? (and (>> ganim-frame 3) #x3) 1)
       (animate-sprites-2x2! npc2-sprite (+ dancer-id 2)))
      (else
       (animate-sprites-2x2! npc2-sprite (+ dancer-id 4)))))

   (when (sprite-collide-sprite player-sprite npc3-sprite)
     (cond 
      ((eq? (and (>> ganim-frame 3) #x3) 0)
       (animate-sprites-2x2! npc3-sprite dancer-id))
      ((eq? (and (>> ganim-frame 3) #x3) 1)
       (animate-sprites-2x2! npc3-sprite (+ dancer-id 2)))
      (else
       (animate-sprites-2x2! npc3-sprite (+ dancer-id 4)))))

   (inc ganim-frame)
   (when (> ganim-frame 23)
     (set! ganim-frame 0))

   )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; future

(defun (update-future)
  (update-sprites-future))

(defun (update-sprites-future)
  0)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; interrupts

 (defint (reset)
   (init-system)

   ;; disable all graphics.
   (set! reg-ppu-ctl 0)
   (set! reg-ppu-mask 0)
   (set! reg-ppu-scroll 0)
   (set! reg-ppu-scroll 0)
   ;; send stuff to the ppu here...

   (init-sound)
   (load-palette)

   ;; ;; set basic ppu registers.  load background from $0000,
   ;; ;; sprites from $1000, and the name table from $2000.
   (set! reg-ppu-ctl #b10001000)
   (set! reg-ppu-mask #b00011110)

   ;; ;; clear sprite shadow
   (memset sprite-shadow #xff)


   (asm
    ;; restart interrupts again
    "cli")


    ;; go into in infinite loop - vblank interrupt takes over
   (asm "loop: jmp loop"))


 ;; main loop is here
 (defint (vblank)
   ;; these need to go first!
   ;; start sprite data dma to the oam now
   (set! reg-oam-dma sprite-dma)
   ;; dma the display list now
   (display-list-execute)

;; (asm "
;; 	lda #%10001110			;show start of sound code time
;; 	sta $2001
;; 	sta $401e				;for VirtuaNES custom build
;; ")

(asm "	jsr FamiToneUpdate")


   ;; ;; that's done, now we're safe to do whatever
    (cond
     ((eq? ggame-mode title-mode) (update-title))
     ((eq? ggame-mode eighties-mode) (update-eighties))    
     (else (update-future)))

    ;; reads the joypad state into memory to save time
    ;; probably premature optimisation?
    (read-joypad)
    (inc gframe)
    (when (not (eq? gdraw-phase 255)) (inc gdraw-phase))

;; (asm "
;; 	sta $401f				;show end of sound code time
;; 	lda #%00001110
;; 	sta $2001
;;  ")

    )
   
(defint (irq))
 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; data follows

(asm "introtitle:")(text "What remains intro!") (byte "0")
(asm "intropress:")(text "Press any key") (byte "0")

(asm "npcsays:")(text "Hey, watch my moves")(byte "0")

(asm "mystring:")
;       xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(text " What remains? TESTING text 12345")

;; bounding box data follows
 (asm "collision_data")
 (byte "2") ;; number of boxes
 (byte "16,16,64,48")
 (byte "144,80,192,112")
 
 ;; stuff still to tidy up follows...
 (asm "palette:")

 (byte "$11,$21,$31,$30")
 (byte "$11,$21,$31,$30")
 (byte "$11,$21,$31,$30")
 (byte "$11,$21,$31,$30")

 (byte "$11,$21,$31,$30")
 (byte "$13,$23,$33,$30")
 (byte "$15,$25,$35,$30")
 (byte "$17,$27,$37,$30")

 (asm "bg:")
 ;; attribute table
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00")
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00")
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0")
 (byte "$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f")

(asm "	.org $c000
	.incbin \"after_the_rain.dmc\"")

 
 ;; interrupt vectors (addresses for functions)
 (asm ".pad $fffa")
 (asm ".word vblank, reset, irq")

 ;; finally all the chr data
 (asm 
  ".incbin \"binary/whatremains-tiles.chr\""
  ".align $1000"
  ".incbin \"binary/whatremains-sprites.chr\""
  ".align $1000")
 
 )
