;; -*- mode: lisp; -*-
;; What Remains 
;; Copyright (C) 2016 What Remains Entertainment Consortium
;;
;; Licence TBD

(do

 ;; NES header follows
 (asm
  ".byte \"NES\",$1a" ;; number of prg-rom blocks
  ".byte $01" ;; number of chr-rom blocks
  ".byte $01" ;; rom control bytes: horizontal mirroring, no sram or trainer, mapper #0
  ".byte $00,$00" ;; filler
  ".byte $00,$00,$00,$00,$00,$00,$00,$00")

    ;; our memory layout
 (defconst sprite-data  "$200") ;; where the sprite control data is
 (defconst sprite-dma   "#$2") ;; dma address is 100X this = $200
 (defconst display-list "$300")
 (defconst tile-data "$400") 
 (defconst pad-data     "$500") ;; cache of the current pad state

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; display primitives
 ;; ------------------
 ;;
 ;; tile-data display primitive: [list of bytes to copy as tile ids]
 (defconst prim-tile-data "#$01")
 ;; tile-value display primitive: [length tile-id] 
 ;; for clearing screen etc - 128 long is about max for timing
 (defconst prim-tile-value "#$02")

 (defconst rom-images "$80")

 ;; code start
 (org #xc000)

 ;; globals that will be removed - honest gov
 (defvar gframe 0)
 (defvar rnd-v 200)
 (defvar text-pos 0)
 (defvar text-time 0)

 ;; the current display list index 
 (defvar display-list-index 0)

 ;; for use as temporaries (careful not to use them over fncalls
 ;; as they will get clobbered)
 (defvar n 0)
 (defvar i 0)
 (defvar j 0)
 (defvar k 0)
 (defvar l 0)
 (defvar start 0)
 (defvar end 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; display list

(defun (display-list-add-byte data)
  (poke! display-list display-list-index data) 
  (inc display-list-index))

(defun (display-list-end-packet prim-id x y nbytes)
  (poke! display-list display-list-index prim-id) 
  (inc display-list-index)
  (poke! display-list display-list-index x)
  (inc display-list-index)
  (poke! display-list display-list-index y)
  (inc display-list-index)
  ;; last byte needs to be size for all primitives
  (poke! display-list display-list-index nbytes) 
  (inc display-list-index))

(defun (display-list-execute)
  ;; is there anything in the queue?
  (if (eq? display-list-index 0) 0 ;; early out (avoid long branch)
    (do
     ;; reverse to read info (lifo for ease/speed)
     (set! display-list-index (- display-list-index 4))

     (set! n (peek display-list (+ display-list-index 3))) ;; store nbytes

     (when (eq? (peek display-list display-list-index) prim-tile-data) 
       (set! start (- display-list-index n))
       (set! end display-list-index)
       (ppu-memcpy2 ppu-name-table-0 
		    (peek display-list (+ display-list-index 1)) ;; x
		    (peek display-list (+ display-list-index 2)) ;; y
		    end ;; w
		    display-list
		    start)) ;; start

     (when (eq? (peek display-list display-list-index) prim-tile-value) ;; tileset
       (set! start (- display-list-index n))
       (ppu-memset2 ppu-name-table-0 
		    (peek display-list (+ display-list-index 1)) ;; x
		    (peek display-list (+ display-list-index 2)) ;; y
		    (peek display-list start) ;; length
		    (peek display-list (+ start 1)))) ;; tile id
     (set! display-list-index (- display-list-index n)))))

(defun (clear-tiles)
  ; nametable 1
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 0 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 0 128 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 1 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 1 128 2)
  ; nametable 2
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 2 0 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 2 128 2)
  (display-list-add-byte 128)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 3 0 2)
  (display-list-add-byte 64)
  (display-list-add-byte 0)
  (display-list-end-packet prim-tile-value 3 128 2))

(defun (display-8x4-image x y loc)
  (set! j loc) (set! k x) (set! l y) ;; store to prevent clobbering
  (set! i 0)
  (while (< i 4)
    (set! start (<< i 4)) ;; * 16
    (set! end (+ start 7))
    (loop n start end (display-list-add-byte (+ j n)))
    (display-list-end-packet prim-tile-data k (+ l (<< i 5)) 8) ;; * 32
    (inc i)))

  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; library code follows

 ;; really crappy random number generator
 (defun (rnd)
   (_rnd))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; input stuff

 (defun (read-joypad)
   ;; need to 'strobe' register before reading
   (set! reg-joypad-0 1)
   (set! reg-joypad-0 0)
   (loop n 0 8
         (poke! pad-data n (and (peek reg-joypad-0) #x1))))

 (defun (pressed key)
   (peek pad-data key))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ppu transfers

 (defun (load-palette)
   ;; copy 32 bytes of bg and sprite palette
   (ppu-memcpy ppu-palette #x20 palette))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; image display

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; text display

 ;; (defun (update-text)
 ;;   (inc text-time)
 ;;   (when (> text-time 10)
 ;;     (poke! tile-data text-pos (peek mystring text-pos))
 ;;     (inc text-pos)
 ;;     (set! text-time 0))
 ;;   ;; reset
 ;;   (when (> text-pos 32)
 ;;     (set! text-pos 0)
 ;;     (loop n 0 32
 ;; 	   (poke! tile-data n 0))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; sprite stuff
 
 ;; 2x2 block sprites
 (defun (setup-character block id)
   (set-sprite-x! id 0)
   (set-sprite-y! id 0)
   (set-sprite-id! id (+ 1 block))

   (set-sprite-x! (+ 1 id) 8)
   (set-sprite-y! (+ 1 id) 0)
   (set-sprite-id! (+ 1 id) (+ 2 block))

   (set-sprite-x! (+ 2 id) 0)
   (set-sprite-y! (+ 2 id) 8)
   (set-sprite-id! (+ 2 id) (+ 17 block))

   (set-sprite-x! (+ 3 id) 8)
   (set-sprite-y! (+ 3 id) 8)
   (set-sprite-id! (+ 3 id) (+ 18 block)))

 (defun (init-sprites)
   ;; clear page #2, which we'll use to hold sprite data
   ;; (memset writes 256 bytes in one go)
   (memset sprite-data 0))

 (defun (update-sprite)
   ;; start sprite data dma to the oam
   ;;(set! reg-oam-dma sprite-dma)
   ;; do sprite stuff here.
   )

(defun (random-image)
  (if (not (eq? gframe 100)) 0
    (do
     ;; test some text
     (loop n 0 31 (display-list-add-byte (peek mystring n)))
     (display-list-end-packet prim-tile-data 1 168 32)

     (set! n (and (_rnd) #x03))
     (cond
      ((eq? n 0) (display-8x4-image 2 20 #x80))
      ((eq? n 1) (display-8x4-image 2 2 #x88))
      ((eq? n 2) (display-8x4-image 2 71 #xc0))
      (else (display-8x4-image 2 13 #xc8))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; interrupts

 (defint (reset)
   ;; disable interrupts while we set stuff up
   (asm "sei"
        ;; make sure we're not using decimal mode
        "cld")
   ;; have to pause here
   (wait-vblank)
   (wait-vblank)
   (asm
    ;; clear out all ram
    "lda #$00"
    "ldx #$00"
    "- sta $000,x"
    "sta $100,x"
    "sta $200,x"
    "sta $300,x"
    "sta $400,x"
    "sta $500,x"
    "sta $600,x"
    "sta $700,x"
    "inx"
    "bne -"
    ;; reset the stack pointer.
    "ldx #$ff"
    "txs")

   ;; disable all graphics.
   (set! reg-ppu-ctl 0)
   (set! reg-ppu-mask 0)
   (set! reg-ppu-scroll 0)
   (set! reg-ppu-scroll 0)
   ;; send stuff to the ppu here...


   (load-palette)

   ;; set basic ppu registers.  load background from $0000,
   ;; sprites from $1000, and the name table from $2000.
   (set! reg-ppu-ctl #b10001000)
   (set! reg-ppu-mask #b00011110)

   ;; (set! i 0)
   ;; (while (< i 4)
   ;;   (set! start (<< i 4)) ;; * 16
   ;;   (set! end (+ start 7))
   ;;   (loop n start end (display-list-add-byte (+ #x80 n)))
   ;;   (display-list-end-packet #x01 0 (+ 2 (<< i 5)) 8) ;; * 32
   ;;   (inc i))
   
   ;; (loop n 0 15 (display-list-add-byte (+ #x80 n)))
   ;; (display-list-end-packet #x01 0 0 8)
   ;; (loop n 16 23 (display-list-add-byte (+ #x80 n)))
   ;; (display-list-end-packet #x01 0 32 8)
   ;; (loop n 32 39 (display-list-add-byte (+ #x80 n)))
   ;; (display-list-end-packet #x01 0 64 8)
   ;; (loop n 48 55 (display-list-add-byte (+ #x80 n)))
   ;; (display-list-end-packet #x01 0 96 8)

   (display-8x4-image 0 34 #x80)
   (display-8x4-image 0 51 #x88)
   (display-8x4-image 1 2 #xc0)
   (display-8x4-image 1 11 #xc8)

   (clear-tiles)
   (set! rnd-reg 123)
   (asm
    ;; restart interrupts again
    "cli"
    ;; go into in infinite loop - vblank interrupt takes over
    "loop: jmp loop"))


 ;; main loop is here
 (defint (vblank)
   ;; move a sprite or two
   (update-sprite)
   (display-list-execute)

   (random-image)

   ;;(update-text)
   ;; reads the joypad state into memory to save time
   ;; probably premature optimisation
   (read-joypad)
   (inc gframe))

 (defint (irq))
 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; data follows

 (asm "mystring:")
;       xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 (text " What remains? TESTING text 1234")
 
 ;; stuff still to tidy up follows...

 (asm "palette:")
 (byte "$38,$00,$00,$00,$00,$02,$03,$04,$01,$02,$03,$0c,$38,$27,$17,$0d")
 (byte "$38,$18,$28,$38,$0c,$1c,$2c,$3c,$03,$13,$23,$33,$09,$19,$29,$39")

 (asm "bg:")
  ;; attribute table
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00")
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00")
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0")
 (byte "$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f")
 (asm ".pad $fffa")

;; interrupt vectors (addresses for functions)
 (asm ".word vblank, reset, irq")

 ;; finally all the chr data
 (asm 
  ".incbin \"binary/tiles.bin\""
  ".align $1000"
  ".incbin \"binary/sprites.chr\""
  ".align $1000")
 
 )
