;; -*- mode: lisp; -*-
;; What Remains 
;; Copyright (C) 2016 What Remains Entertainment Consortium
;;
;; Licence TBD

(do
 ;; NES header follows
 (asm
  ".byte \"NES\",$1a" ;; number of prg-rom blocks
  ".byte $01" ;; number of chr-rom blocks
  ".byte $01" ;; rom control bytes: horizontal mirroring, no sram or trainer, mapper #0
  ".byte $00,$00" ;; filler
  ".byte $00,$00,$00,$00,$00,$00,$00,$00")

    ;; our memory layout

 (defconst sprite-shadow  "$200") ;; where the sprite control data is
 (defconst poke-test "$300")
 (defconst display-list "$400") ;; the display list

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; display primitives
 ;; ------------------
 ;;
 ;; 
 ;; tile-data display primitive: [list of bytes to copy as tile ids]
 (defconst prim-tile-data "#$01")
 ;; tile-value display primitive: [length tile-id] 
 ;; for clearing screen etc - 128 long is about max for timing
 (defconst prim-tile-value "#$02")
 ;; 2x2 tile quad [tile top left id]
 (defconst prim-quad "#$03")



 ;; code start
 (org #xc000)

 (defvar n 0)
 (defvar i 0)
 (defvar j 0)
 (defvar k 0)
 (defvar l 0)
 (defvar m 0)
 (defvar o 0)
 (defvar p 0)
 (defvar start 0)
 (defvar end 0)

 (defvar assertpos 0)
 ;; the current display list index 
 (defvar display-list-index 0)

(defun (assert v)
  (if (eq? v 1)
      (ppu-memset2 ppu-name-table-0 0 assertpos 1 1)
      (ppu-memset2 ppu-name-table-0 0 assertpos 1 2))
  (inc assertpos))

(defun (test-simple) 1)
(defun (test2-argret a) a)
(defun (test3-multifn a)
  (test3-b #xcd)
  a)
(defun (test3-b b) 99)
(defun (test4-secondarg a b) b)
(defun (test5-multifn2 a b)
  (test5-b 10 20 a)
  b)
(defun (test5-b a b c) 0)
(defun (test6-assignarg a)
  (set! a 1) 
  a)

(defun (test7-multiarg a b c d e f g)
  (+ a (+ b (+ c (+ d (+ e (+ f g)))))))

(defun (test8-recur count num)
  (if (eq? count 0) num
    (test8-recur (+ count 1) (- num 1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; display list

(defun (display-list-add-byte data)
  (poke! display-list display-list-index data) 
  (inc display-list-index))

(defun (display-list-end-packet prim-id x y nbytes)
  (poke! display-list display-list-index prim-id) 
  (inc display-list-index)
  (poke! display-list display-list-index x)
  (inc display-list-index)
  (poke! display-list display-list-index y)
  (inc display-list-index)
  ;; last byte needs to be size for all primitives
  (poke! display-list display-list-index nbytes) 
  (inc display-list-index))

(defun (display-list-execute)
  ;; is there anything in the queue?
  (if (eq? display-list-index 0) 0 ;; early out (avoid long branch)
    (do
     ;; reverse to read info (lifo for ease/speed)
     (set! display-list-index (- display-list-index 4))

     (set! n (peek display-list (+ display-list-index 3))) ;; store nbytes
     (set! start (- display-list-index n))
     (set! end display-list-index)
     (set! i (peek display-list (+ start 1)))

     ;; update tile data
     (when (eq? (peek display-list display-list-index) prim-tile-data) 
       (set! end display-list-index)
       (ppu-memcpy2 ppu-name-table-0 
		    (peek display-list (+ display-list-index 1))
		    (peek display-list (+ display-list-index 2))
		    end ;; w
		    display-list
		    start)) ;; start

     ;; update arbitrary length strips of one value (RLE)
     (when (eq? (peek display-list display-list-index) prim-tile-value) ;; tileset
       (assert (eq? p (peek display-list (+ display-list-index 2))))
       (ppu-memset2 ppu-name-table-0 
		    (peek display-list (+ display-list-index 1))
		    (peek display-list (+ display-list-index 2))
		    (peek display-list start) ;; length
		    (peek display-list (+ start 1)))) ;; tile id

     (when (eq? (peek display-list display-list-index) prim-quad) 
       (ppu-memset2 ppu-name-table-0 
		    (peek display-list (+ display-list-index 1))
		    (peek display-list (+ display-list-index 2))
		    1 ;; w
		    (+ i 16)) ;; start
       ;;(ppu-memset-more 1 (+ i 1))
       ;(ppu-memset2 ppu-name-table-0 
;		    o (+ p 32) ;; y
;		    1 ;; w
;		    (+ i 16)) ;; start
       ;;(ppu-memset-more 1 (+ i 17))
       )
     
     (set! display-list-index (- display-list-index n)))))


(defun (display-phase-1 x y loc)
  (set! j loc) (set! k (+ x 12)) (set! l y) ;; store to prevent clobbering
  (set! i 0)
  ;; draw top part
  (loop n 0 7 (display-list-add-byte (+ j n)))
  (display-list-end-packet prim-tile-data 1 k 8)
  (loop n 8 15 (display-list-add-byte (+ 8 (+ j n))))
  (display-list-end-packet prim-tile-data 1 (+ k 32) 8)

  ;; first row with rep
  (display-list-add-byte (+ 8 (+ j 8)))
  (display-list-add-byte (+ 8 (+ j 9)))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (display-list-add-byte (+ 8 (+ j 14)))
  (display-list-add-byte (+ 8 (+ j 15)))
  (display-list-end-packet prim-tile-data 1 (+ k 62) 12)

  ;; second row with rep
  (display-list-add-byte (+ 8 (+ j 8)))
  (display-list-add-byte (+ 8 (+ j 9)))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (display-list-add-byte (+ 8 (+ j 14)))
  (display-list-add-byte (+ 8 (+ j 15)))
  (display-list-end-packet prim-tile-data 1 (+ k 92) 16)

  ;; third row with rep
  (display-list-add-byte (+ 8 (+ j 8)))
  (display-list-add-byte (+ 8 (+ j 9)))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (display-list-add-byte (+ 8 (+ j 14)))
  (display-list-add-byte (+ 8 (+ j 15)))
  (display-list-end-packet prim-tile-data 1 (+ k 122) 20)

  ;; forth row with rep
  (display-list-add-byte (+ 8 (+ j 8)))
  (display-list-add-byte (+ 8 (+ j 9)))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (display-list-add-byte (+ 8 (+ j 14)))
  (display-list-add-byte (+ 8 (+ j 15)))
  (display-list-end-packet prim-tile-data 1 (+ k 152) 24)

  ;; turning back
  (display-list-add-byte (+ 24 (+ j 8)))
  (display-list-add-byte (+ 24 (+ j 9)))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (loop n 10 13 (display-list-add-byte (+ 8 (+ j n))))
  (display-list-add-byte (+ 24 (+ j 14)))
  (display-list-add-byte (+ 24 (+ j 15)))
  (display-list-end-packet prim-tile-data 1 (+ k 184) 24)


  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; interrupts

 (defun (load-palette)
   ;; copy 32 bytes of bg and sprite palette
   (ppu-memcpy ppu-palette #x20 palette))

 (defint (reset)  
   ;; disable interrupts while we set stuff up
   (asm "sei"
        ;; make sure we're not using decimal mode
        "cld")
   ;; have to pause here
   (wait-vblank)
   (wait-vblank)
   (asm
    ;; clear out all ram
    "lda #$00"
    "ldx #$00"
    "- sta $000,x"
    "sta $100,x"
    "sta $200,x"
    "sta $300,x"
    "sta $400,x"
    "sta $500,x"
    "sta $600,x"
    "sta $700,x"
    "inx"
    "bne -"
    ;; reset the stack pointer.
    "ldx #$ff"
    "txs")

   (set! spare-reg-h 1)

   ;; disable all graphics.
   (set! reg-ppu-ctl 0)
   (set! reg-ppu-mask 0)
   (set! reg-ppu-scroll 0)
   (set! reg-ppu-scroll 0)
   ;; send stuff to the ppu here...
   (load-palette)

   ;; logic and simple maths
   (assert 1)
   (assert (not 0))
   (assert (eq? 120 120))
   (assert (eq? (+ 3 8) 11))
   (assert (- 2 1))
   (assert (eq? (* 2 1) 2))
   (assert (eq? (* 1 2) 2))
   (assert (eq? (* 5 20) 100))
   (assert (eq? (* 20 5) 100))
   (assert (eq? -4 (+ -2 -2)))
   (assert (eq? 0 (+ -2 2)))

   ;; variables
   (set! n 1)
   (assert n)

   ;; branches
   (assert (if 0 0 1))
   (assert (when 1 1))

   ;; more numbers
   (assert (< 1 3))
   (assert (<= 2 2))
   (assert (> 50 10))
   (assert (and #b00000001 #b01010101))
   (assert (or #b00000000 #b00000001))
   (assert (xor #b11110000 #b11110001))

   ;; inc/dec
   (inc n)
   (assert (eq? n 2))
   (dec n)
   (assert n)

   ;; shifting
   (assert (>> #b00000010 1))
   (assert (>> #b00100000 5))
   (assert (eq? (<< #b00000001 5) 32))

   ;; memory access
   (poke! poke-test 200) 
   (assert (eq? (peek poke-test) 200))
   (poke! poke-test 40 200) 
   (assert (eq? (peek poke-test 40) 200))

   ;; functions
   (assert (test-simple))
   (assert (test2-argret 1))
   (assert (test3-multifn 1))
   (assert (test4-secondarg 0 1))
   (assert (test5-multifn2 0 1))
   (assert (test6-assignarg 0))
   (assert (eq? (test7-multiarg 1 2 3 4 5 6 7) 28))
   (assert (eq? (test8-recur 0 10) 10))

   ;; loops
   (set! n 0)
   (while (< n 4)
     (inc n))
   (assert (eq? n 4))

   (set! k 0)
   (loop n 0 5 (inc k))
   (assert (eq? k 6))

   ;;(display-phase-1 0 0 #x10)
   (display-list-add-byte 128)
   (display-list-add-byte 2)
   (display-list-end-packet prim-tile-value 2 0 2)

   ;; set basic ppu registers.  load background from $0000,
   ;; sprites from $1000, and the name table from $2000.
   (set! reg-ppu-ctl #b10001000)
   (set! reg-ppu-mask #b00011110)


   (asm
    ;; restart interrupts again
    "cli"
    ;; go into in infinite loop - vblank interrupt takes over
    "loop: jmp loop"))


 ;; main loop is here
 (defint (vblank)
   (display-list-execute)
   )
 (defint (irq))
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; data follows
;; interrupt vectors (addresses for functions)
 (asm ".word vblank, reset, irq")
  ;; stuff still to tidy up follows...

 (asm "palette:")
 (byte "$0d,$00,$00,$00,$00,$02,$03,$04,$01,$02,$03,$0c,$0c,$1c,$2c,$3c")
 (byte "$0d,$18,$28,$38,$0c,$1c,$2c,$3c,$03,$13,$23,$33,$09,$19,$29,$39")

 (asm "bg:")
  ;; attribute table
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00")
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00")
 (byte "$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0")
 (byte "$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f")
 (asm ".pad $fffa")

;; interrupt vectors (addresses for functions)
 (asm ".word vblank, reset, irq")

 ;; finally all the chr data
 (asm 
  ".incbin \"binary/test2.chr\"")
 

 )
